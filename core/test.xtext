grammar xtext

terminal WS         : /\s+/;
terminal ID returns string: /\^?[_a-zA-Z][\w_]*/;
terminal INT returns number: /[0-9]+/;
terminal string: /"[^"]*"|'[^']*'/;



Grammar:
	'grammar' Name=GrammarID ('with' UsedGrammars+=[Grammar|GrammarID] (',' UsedGrammars+=[Grammar|GrammarID])*)?
	(definesHiddenTokens?='hidden' '(' (HiddenTokens+=[AbstractRule|RuleID] (',' HiddenTokens+=[AbstractRule|RuleID])*)? ')')?
	MetamodelDeclarations+=AbstractMetamodelDeclaration*
	(rules+=AbstractRule)+
;

GrammarID returns string:
	ID ('.' ID)*;

AbstractRule : ParserRule | TerminalRule | EnumRule;

AbstractMetamodelDeclaration :
	GeneratedMetamodel | ReferencedMetamodel;

GeneratedMetamodel :
	'generate' Name=ID EPackage=[string] ('as' Alias=ID)?;

ReferencedMetamodel :
	'import' EPackage=[string] ('as' Alias=ID)?;


Annotation:
	'@' Name = ID
;

ParserRule :
	(
	  ^fragment?='fragment' RuleNameAndParams (wildcard?='*' | ('returns' Type=TypeRef)?)
	| RuleNameAndParams ('returns' Type=TypeRef)?
	)
	(DefinesHiddenTokens?='hidden' '(' (HiddenTokens+=[AbstractRule|RuleID] (',' HiddenTokens+=[AbstractRule|RuleID])*)? ')')? ':'
		Alternatives=Alternatives
	';'
;

RuleNameAndParams:
	Name=ID ('<' (Parameters+=Parameter (',' Parameters+=Parameter)*)? '>')?
;

Parameter:
	Name=ID
;

TypeRef :
	(Metamodel=[AbstractMetamodelDeclaration] '::')? Classifier=[string]
;

Alternatives:
	ConditionalBranch ({Alternatives.Elements+=current} ('|' Elements+=ConditionalBranch)+)?
;

ConditionalBranch:
	  UnorderedGroup
	| {Group} '<' GuardCondition=Disjunction '>' (Elements+=AbstractToken)+
;

UnorderedGroup:
	Group ({UnorderedGroup.Elements+=current} ('&' Elements+=Group)+)?
;

Group:
	AbstractToken ({Group.Elements+=current} (Elements+=AbstractToken)+)?
;

AbstractToken:
	AbstractTokenWithCardinality |
	Action
;

AbstractTokenWithCardinality:
	(Assignment | AbstractTerminal) Cardinality=('?'|'*'|'+')?
;

Action:
	'{' Type=TypeRef ('.' Feature=ID Operator=('='|'+=') 'current')? '}'
;

AbstractTerminal:
	Keyword |
	RuleCall |
	ParenthesizedElement |
	PredicatedKeyword |
	PredicatedRuleCall |
	PredicatedGroup
;

Keyword :
	Value=string
;

RuleCall :
	Rule=[AbstractRule|RuleID] ('<' Arguments+=NamedArgument (',' Arguments+=NamedArgument)* '>')?
;

NamedArgument:
	( Parameter=[Parameter|ID] CalledByName?= '=')?
	( Value=Disjunction )
;

LiteralCondition:
	{LiteralCondition} (True?='true' | 'false')
;

Disjunction:
	Conjunction ({Disjunction.Left=current} '|' Right=Conjunction)*
;

Conjunction:
	Negation ({Conjunction.Left=current} '&' Right=Negation)*
;

Negation:
	Atom | {Negation} '!' Value=Negation
;

Atom:
	ParameterReference | ParenthesizedCondition | LiteralCondition
;

ParenthesizedCondition:
	'(' Disjunction ')'
;

ParameterReference:
	Parameter=[Parameter|ID]
;

TerminalRuleCall:
	Rule=[AbstractRule|RuleID]
;

RuleID returns string:
	ID ('::' ID)*
;

PredicatedKeyword:
	(Predicated?='=>' | FirstSetPredicated?='->') Value=string
;

PredicatedRuleCall:
	(Predicated?='=>' | FirstSetPredicated?='->') Rule=[AbstractRule|RuleID] ('<' Arguments+=NamedArgument (',' Arguments+=NamedArgument)* '>')?
;

Assignment:
	(Predicated?='=>' | FirstSetPredicated?='->')? Feature=ID Operator=('+='|'='|'?=') ^Terminal=AssignableTerminal
;

AssignableTerminal:
	Keyword | RuleCall | ParenthesizedAssignableElement | CrossReference
;

ParenthesizedAssignableElement:
	'(' AssignableAlternatives ')'
;

AssignableAlternatives:
	AssignableTerminal ({Alternatives.Elements+=current} ('|' Elements+=AssignableTerminal)+)?
;

CrossReference :
	'[' Type=TypeRef ('|' ^Terminal=CrossReferenceableTerminal )? ']'
;

CrossReferenceableTerminal:
	Keyword | RuleCall
;

ParenthesizedElement:
	'(' Alternatives ')'
;

PredicatedGroup:
	(Predicated?='=>' | FirstSetPredicated?='->') '(' Elements+=Alternatives ')'
;

TerminalRule :
	'terminal' (^Fragment?='fragment' Name=ID | Name=ID ('returns' Type=TypeRef)?) ':'
		Regex=RegexLiteral
	';'
;

terminal RegexLiteral returns string: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\//;

TerminalAlternatives:
	TerminalGroup ({Alternatives.Elements+=current} ('|' Elements+=TerminalGroup)+)?
;

TerminalGroup:
	TerminalToken ({Group.Elements+=current} (Elements+=TerminalToken)+)?
;

TerminalToken:
	TerminalTokenElement Cardinality=('?'|'*'|'+')?
;

TerminalTokenElement:
	CharacterRange | TerminalRuleCall | ParenthesizedTerminalElement | AbstractNegatedToken | Wildcard
;

ParenthesizedTerminalElement:
	'(' TerminalAlternatives ')'
;

AbstractNegatedToken:
	NegatedToken | UntilToken
;

NegatedToken:
	'!' ^Terminal=TerminalTokenElement
;

UntilToken:
	'->' ^Terminal=TerminalTokenElement
;

Wildcard:
	{Wildcard} '.'
;

CharacterRange:
	Keyword ( {CharacterRange.Left=current} '..' Right=Keyword)?
;

EnumRule:
	'enum' Name=ID ('returns' Type=TypeRef)? ':'
		Alternatives=EnumLiterals
	';'
;

EnumLiterals:
	EnumLiteralDeclaration ({Alternatives.Elements+=current} ('|' Elements+=EnumLiteralDeclaration)+)?
;

EnumLiteralDeclaration:
	EnumLiteral=[EnumLiterals|ID] ('=' Literal=Keyword)?
;
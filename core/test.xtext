grammar xtext

terminal WS         : /\s+/;
terminal ID: /\^?[_a-zA-Z][\w_]*/;
terminal INT: /[0-9]+/;
terminal STRING: /"[^"]*"|'[^']*'/;
terminal ML_COMMENT : /NOT_IMPLEMENTED/;
terminal SL_COMMENT : /\/\/.*/;



Grammar:
	'grammar' name=GrammarID ('with' usedGrammars+=[Grammar|GrammarID] (',' usedGrammars+=[Grammar|GrammarID])*)?
	(definesHiddenTokens?='hidden' '(' (hiddenTokens+=[AbstractRule|RuleID] (',' hiddenTokens+=[AbstractRule|RuleID])*)? ')')?
	metamodelDeclarations+=AbstractMetamodelDeclaration*
	(rules+=AbstractRule)+
;

GrammarID returns EString:
	ID ('.' ID)*;

AbstractRule : ParserRule | TerminalRule | EnumRule;

AbstractMetamodelDeclaration :
	GeneratedMetamodel | ReferencedMetamodel;

GeneratedMetamodel :
	'generate' name=ID ePackage=[AbstractMetamodelDeclaration|STRING] ('as' alias=ID)?;

ReferencedMetamodel :
	'import' ePackage=[AbstractMetamodelDeclaration|STRING] ('as' alias=ID)?;


Annotation returns Annotation:
	'@' name = ID
;

ParserRule :
	(annotations += Annotation)*
	(
	  ^fragment?='fragment' RuleNameAndParams (wildcard?='*' | ('returns' type=TypeRef)?)
	| RuleNameAndParams ('returns' type=TypeRef)?
	)
	(definesHiddenTokens?='hidden' '(' (hiddenTokens+=[AbstractRule|RuleID] (',' hiddenTokens+=[AbstractRule|RuleID])*)? ')')? ':'
		alternatives=Alternatives
	';'
;

RuleNameAndParams returns ParserRule:
	name=ID ('<' (parameters+=Parameter (',' parameters+=Parameter)*)? '>')?
;

Parameter:
	name=ID
;

TypeRef :
	(metamodel=[AbstractMetamodelDeclaration] '::')? classifier=[STRING]
;

Alternatives returns AbstractElement:
	ConditionalBranch ({Alternatives.elements+=current} ('|' elements+=ConditionalBranch)+)?
;

ConditionalBranch returns AbstractElement:
	  UnorderedGroup
	| {Group} '<' guardCondition=Disjunction '>' (elements+=AbstractToken)+
;

UnorderedGroup returns AbstractElement:
	Group ({UnorderedGroup.elements+=current} ('&' elements+=Group)+)?
;

Group returns AbstractElement:
	AbstractToken ({Group.elements+=current} (elements+=AbstractToken)+)?
;

AbstractToken returns AbstractElement:
	AbstractTokenWithCardinality |
	Action
;

AbstractTokenWithCardinality returns AbstractElement:
	(Assignment | AbstractTerminal) cardinality=('?'|'*'|'+')?
;

Action returns Action:
	'{' type=TypeRef ('.' feature=ID operator=('='|'+=') 'current')? '}'
;

AbstractTerminal returns AbstractElement:
	Keyword |
	RuleCall |
	ParenthesizedElement |
	PredicatedKeyword |
	PredicatedRuleCall |
	PredicatedGroup
;

Keyword :
	value=STRING
;

RuleCall :
	rule=[AbstractRule|RuleID] ('<' arguments+=NamedArgument (',' arguments+=NamedArgument)* '>')?
;

NamedArgument:
	( parameter=[Parameter|ID] calledByName?= '=')?
	( value=Disjunction )
;

LiteralCondition:
	{LiteralCondition} (true?='true' | 'false')
;

Disjunction returns Condition:
	Conjunction ({Disjunction.left=current} '|' right=Conjunction)*
;

Conjunction returns Condition:
	Negation ({Conjunction.left=current} '&' right=Negation)*
;

Negation returns Condition:
	Atom | {Negation} '!' value=Negation
;

Atom returns Condition:
	ParameterReference | ParenthesizedCondition | LiteralCondition
;

ParenthesizedCondition returns Condition:
	'(' Disjunction ')'
;

ParameterReference:
	parameter=[Parameter|ID]
;

TerminalRuleCall returns RuleCall:
	rule=[AbstractRule|RuleID]
;

RuleID returns EString:
	ID ('::' ID)*
;

ID returns EString:
	ID | 'true' | 'false'
;

PredicatedKeyword returns Keyword:
	(predicated?='=>' | firstSetPredicated?='->') value=STRING
;

PredicatedRuleCall returns RuleCall:
	(predicated?='=>' | firstSetPredicated?='->') rule=[AbstractRule|RuleID] ('<' arguments+=NamedArgument (',' arguments+=NamedArgument)* '>')?
;

Assignment returns Assignment:
	(predicated?='=>' | firstSetPredicated?='->')? feature=ID operator=('+='|'='|'?=') ^terminal=AssignableTerminal
;

AssignableTerminal returns AbstractElement:
	Keyword | RuleCall | ParenthesizedAssignableElement | CrossReference
;

ParenthesizedAssignableElement returns AbstractElement:
	'(' AssignableAlternatives ')'
;

AssignableAlternatives returns AbstractElement:
	AssignableTerminal ({Alternatives.elements+=current} ('|' elements+=AssignableTerminal)+)?
;

CrossReference :
	'[' type=TypeRef ('|' ^terminal=CrossReferenceableTerminal )? ']'
;

CrossReferenceableTerminal returns AbstractElement:
	Keyword | RuleCall
;

ParenthesizedElement returns AbstractElement:
	'(' Alternatives ')'
;

PredicatedGroup returns Group:
	(predicated?='=>' | firstSetPredicated?='->') '(' elements+=Alternatives ')'
;

TerminalRule :
	(annotations += Annotation)*
	'terminal' (^fragment?='fragment' name=ID | name=ID ('returns' type=TypeRef)?) ':'
		regex=Regex
	';'
;

terminal Regex: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\//;

TerminalAlternatives returns AbstractElement:
	TerminalGroup ({Alternatives.elements+=current} ('|' elements+=TerminalGroup)+)?
;

TerminalGroup returns AbstractElement:
	TerminalToken ({Group.elements+=current} (elements+=TerminalToken)+)?
;

TerminalToken returns AbstractElement:
	TerminalTokenElement cardinality=('?'|'*'|'+')?
;

TerminalTokenElement returns AbstractElement:
	CharacterRange | TerminalRuleCall | ParenthesizedTerminalElement | AbstractNegatedToken | Wildcard | ^EOF
;

ParenthesizedTerminalElement returns AbstractElement:
	'(' TerminalAlternatives ')'
;

AbstractNegatedToken:
	NegatedToken | UntilToken
;

NegatedToken:
	'!' ^terminal=TerminalTokenElement
;

UntilToken:
	'->' ^terminal=TerminalTokenElement
;

Wildcard:
	{Wildcard} '.'
;

^EOF:
	{^EOF} 'EOF'
;

CharacterRange returns AbstractElement:
	Keyword ( {CharacterRange.left=current} '..' right=Keyword)?
;

EnumRule:
	(annotations += Annotation)*
	'enum' name=ID ('returns' type=TypeRef)? ':'
		alternatives=EnumLiterals
	';'
;

EnumLiterals returns AbstractElement:
	EnumLiteralDeclaration ({Alternatives.elements+=current} ('|' elements+=EnumLiteralDeclaration)+)?
;

EnumLiteralDeclaration:
	enumLiteral=[EnumLiterals|ID] ('=' literal=Keyword)?
;
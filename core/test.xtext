grammar xtext

terminal WS         : /\s+/;
terminal ID returns string: /\^?[_a-zA-Z][\w_]*/;
terminal INT returns number: /[0-9]+/;
terminal string: /"[^"]*"|'[^']*'/;
terminal ML_COMMENT : /NOT_IMPLEMENTED/;
terminal SL_COMMENT : /\/\/.*/;



Grammar:
	'grammar' name=GrammarID ('with' usedGrammars+=[Grammar|GrammarID] (',' usedGrammars+=[Grammar|GrammarID])*)?
	(definesHiddenTokens?='hidden' '(' (hiddenTokens+=[AbstractRule|RuleID] (',' hiddenTokens+=[AbstractRule|RuleID])*)? ')')?
	metamodelDeclarations+=AbstractMetamodelDeclaration*
	(rules+=AbstractRule)+
;

GrammarID returns string:
	ID ('.' ID)*;

AbstractRule : ParserRule | TerminalRule | EnumRule;

AbstractMetamodelDeclaration :
	GeneratedMetamodel | ReferencedMetamodel;

GeneratedMetamodel :
	'generate' name=ID ePackage=[string] ('as' alias=ID)?;

ReferencedMetamodel :
	'import' ePackage=[string] ('as' alias=ID)?;


Annotation:
	'@' name = ID
;

ParserRule :
	(annotations += Annotation)*
	(
	  ^fragment?='fragment' RuleNameAndParams (wildcard?='*' | ('returns' type=TypeRef)?)
	| RuleNameAndParams ('returns' type=TypeRef)?
	)
	(definesHiddenTokens?='hidden' '(' (hiddenTokens+=[AbstractRule|RuleID] (',' hiddenTokens+=[AbstractRule|RuleID])*)? ')')? ':'
		alternatives=Alternatives
	';'
;

RuleNameAndParams:
	name=ID ('<' (parameters+=Parameter (',' parameters+=Parameter)*)? '>')?
;

Parameter:
	name=ID
;

TypeRef :
	(metamodel=[AbstractMetamodelDeclaration] '::')? classifier=[string]
;

Alternatives:
	ConditionalBranch ({Alternatives.elements+=current} ('|' elements+=ConditionalBranch)+)?
;

ConditionalBranch:
	  UnorderedGroup
	| {Group} '<' guardCondition=Disjunction '>' (elements+=AbstractToken)+
;

UnorderedGroup:
	Group ({UnorderedGroup.elements+=current} ('&' elements+=Group)+)?
;

Group:
	AbstractToken ({Group.elements+=current} (elements+=AbstractToken)+)?
;

AbstractToken:
	AbstractTokenWithCardinality |
	Action
;

AbstractTokenWithCardinality:
	(Assignment | AbstractTerminal) cardinality=('?'|'*'|'+')?
;

Action:
	'{' type=TypeRef ('.' feature=ID operator=('='|'+=') 'current')? '}'
;

AbstractTerminal:
	Keyword |
	RuleCall |
	ParenthesizedElement |
	PredicatedKeyword |
	PredicatedRuleCall |
	PredicatedGroup
;

Keyword :
	value=string
;

RuleCall :
	rule=[AbstractRule|RuleID] ('<' arguments+=NamedArgument (',' arguments+=NamedArgument)* '>')?
;

NamedArgument:
	( parameter=[Parameter|ID] calledByName?= '=')?
	( value=Disjunction )
;

LiteralCondition:
	{LiteralCondition} (true?='true' | 'false')
;

Disjunction:
	Conjunction ({Disjunction.left=current} '|' right=Conjunction)*
;

Conjunction:
	Negation ({Conjunction.left=current} '&' right=Negation)*
;

Negation:
	Atom | {Negation} '!' value=Negation
;

Atom:
	ParameterReference | ParenthesizedCondition | LiteralCondition
;

ParenthesizedCondition:
	'(' Disjunction ')'
;

ParameterReference:
	parameter=[Parameter|ID]
;

TerminalRuleCall:
	rule=[AbstractRule|RuleID]
;

RuleID returns string:
	ID ('::' ID)*
;

ID returns string:
	ID | 'true' | 'false'
;

PredicatedKeyword:
	(predicated?='=>' | firstSetPredicated?='->') value=string
;

PredicatedRuleCall:
	(predicated?='=>' | firstSetPredicated?='->') rule=[AbstractRule|RuleID] ('<' arguments+=NamedArgument (',' arguments+=NamedArgument)* '>')?
;

Assignment:
	(predicated?='=>' | firstSetPredicated?='->')? feature=ID operator=('+='|'='|'?=') ^terminal=AssignableTerminal
;

AssignableTerminal:
	Keyword | RuleCall | ParenthesizedAssignableElement | CrossReference
;

ParenthesizedAssignableElement:
	'(' AssignableAlternatives ')'
;

AssignableAlternatives:
	AssignableTerminal ({Alternatives.elements+=current} ('|' elements+=AssignableTerminal)+)?
;

CrossReference :
	'[' type=TypeRef ('|' ^terminal=CrossReferenceableTerminal )? ']'
;

CrossReferenceableTerminal:
	Keyword | RuleCall
;

ParenthesizedElement:
	'(' Alternatives ')'
;

PredicatedGroup:
	(predicated?='=>' | firstSetPredicated?='->') '(' elements+=Alternatives ')'
;

TerminalRule :
	(annotations += Annotation)*
	'terminal' (^fragment?='fragment' name=ID | name=ID ('returns' type=TypeRef)?) ':'
		regex=Regex
	';'
;

terminal Regex returns string: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\//;

TerminalAlternatives:
	TerminalGroup ({Alternatives.elements+=current} ('|' elements+=TerminalGroup)+)?
;

TerminalGroup:
	TerminalToken ({Group.elements+=current} (elements+=TerminalToken)+)?
;

TerminalToken:
	TerminalTokenElement cardinality=('?'|'*'|'+')?
;

TerminalTokenElement:
	CharacterRange | TerminalRuleCall | ParenthesizedTerminalElement | AbstractNegatedToken | Wildcard
;

ParenthesizedTerminalElement:
	'(' TerminalAlternatives ')'
;

AbstractNegatedToken:
	NegatedToken | UntilToken
;

NegatedToken:
	'!' ^terminal=TerminalTokenElement
;

UntilToken:
	'->' ^terminal=TerminalTokenElement
;

Wildcard:
	{Wildcard} '.'
;

CharacterRange:
	Keyword ( {CharacterRange.left=current} '..' right=Keyword)?
;

EnumRule:
	(annotations += Annotation)*
	'enum' name=ID ('returns' type=TypeRef)? ':'
		alternatives=EnumLiterals
	';'
;

EnumLiterals:
	EnumLiteralDeclaration ({Alternatives.elements+=current} ('|' elements+=EnumLiteralDeclaration)+)?
;

EnumLiteralDeclaration:
	enumLiteral=[EnumLiterals|ID] ('=' literal=Keyword)?
;
grammar xtext

terminal WS         : /\s+/;
terminal ID returns string: /\^?[_a-zA-Z][\w_]*/;
terminal INT returns number: /[0-9]+/;
terminal string: /"[^"]*"|'[^']*'/;



Grammar:
	'grammar' Name=ID ('with' UsedGrammars+=[Grammar|ID] (',' UsedGrammars+=[Grammar|ID])*)?
	(definesHiddenTokens?='hidden' '(' (HiddenTokens+=[AbstractRule|ID] (',' HiddenTokens+=[AbstractRule|ID])*)? ')')?
	MetamodelDeclarations+=AbstractMetamodelDeclaration*
	(rules+=AbstractRule)+
;

GrammarID returns string:
	ID ('.' ID)*;

AbstractRule : ParserRule | TerminalRule | EnumRule;

AbstractMetamodelDeclaration :
	GeneratedMetamodel | ReferencedMetamodel;

GeneratedMetamodel :
	'generate' Name=ID EPackage=[string] ('as' Alias=ID)?;

ReferencedMetamodel :
	'import' EPackage=[string] ('as' Alias=ID)?;


Annotation:
	'@' Name = ID
;

ParserRule :
	(
	  ^fragment?='fragment' Name=ID ('<' (Parameters+=Parameter (',' Parameters+=Parameter)*)? '>')? (wildcard?='*' | ('returns' Type=ID)?)
	| Name=ID ('<' (Parameters+=Parameter (',' Parameters+=Parameter)*)? '>')? ('returns' Type=ID)?
	)
	(DefinesHiddenTokens?='hidden' '(' (HiddenTokens+=[AbstractRule|ID] (',' HiddenTokens+=[AbstractRule|ID])*)? ')')? ':'
		Alternatives=Alternatives
	';'
;

RuleNameAndParams:
	Name=ID ('<' (Parameters+=Parameter (',' Parameters+=Parameter)*)? '>')?
;

Parameter:
	Name=ID
;

Alternatives:
	Elements+=UnorderedGroup ('|' Elements+=UnorderedGroup)*
;

UnorderedGroup:
	Elements+=Group ('&' Elements+=Group)*
;

Group:
	Elements+=AbstractToken*
;

AbstractToken:
	AbstractTokenWithCardinality |
	Action
;

AbstractTokenWithCardinality:
	(Assignment=Assignment | ^Terminal=AbstractTerminal) Cardinality=('?'|'*'|'+')?
;

Action:
	'{' Type=[ParserRule|ID] ('.' Feature=ID Operator=('='|'+=') 'current')? '}'
;

AbstractTerminal:
	Keyword |
	RuleCall |
	ParenthesizedElement |
	PredicatedKeyword |
	PredicatedRuleCall |
	PredicatedGroup
;

Keyword :
	Value=string
;

RuleCall :
	Rule=[AbstractRule|RuleID] ('<' Arguments+=NamedArgument (',' Arguments+=NamedArgument)* '>')?
;

NamedArgument:
	( Parameter=[Parameter|ID] CalledByName?= '=')?
	( Value=Disjunction )
;

LiteralCondition:
	{LiteralCondition} (True?='true' | 'false')
;

Disjunction:
	Left=Conjunction ('|' Right=Conjunction)?
;

Conjunction:
	Left=Negation ('&' Right=Negation)?
;

Negation:
	Atom | {Negation} '!' Value=Negation
;

Atom:
	ParameterReference | ParenthesizedCondition | LiteralCondition
;

ParenthesizedCondition:
	'(' Disjunction ')'
;

ParameterReference:
	Parameter=[Parameter|ID]
;

TerminalRuleCall:
	Rule=[AbstractRule|RuleID]
;

RuleID returns string:
	ID ('::' ID)*
;

PredicatedKeyword:
	(Predicated?='=>' | FirstSetPredicated?='->') Value=string
;

PredicatedRuleCall:
	(Predicated?='=>' | FirstSetPredicated?='->') Rule=[AbstractRule|RuleID] ('<' Arguments+=NamedArgument (',' Arguments+=NamedArgument)* '>')?
;

Assignment:
	(Predicated?='=>' | FirstSetPredicated?='->')? Feature=ID Operator=('+='|'='|'?=') ^Terminal=AssignableTerminal
;

AssignableTerminal:
	Keyword | RuleCall | ParenthesizedAssignableElement | CrossReference
;

ParenthesizedAssignableElement:
	'(' Alternatives=AssignableAlternatives ')'
;

AssignableAlternatives:
	Elements+=AssignableTerminal ('|' Elements+=AssignableTerminal)*
;

CrossReference :
	'[' Type=[ParserRule|ID] ('|' ^Terminal=CrossReferenceableTerminal )? ']'
;

CrossReferenceableTerminal:
	Keyword | RuleCall
;

ParenthesizedElement:
	'(' Alternatives=Alternatives ')'
;

PredicatedGroup:
	(Predicated?='=>' | FirstSetPredicated?='->') '(' Elements+=Alternatives ')'
;

TerminalRule :
	'terminal' (^Fragment?='fragment' Name=ID | Name=ID ('returns' Type=ID)?) ':'
		Regex=RegexLiteral
	';'
;

terminal RegexLiteral returns string: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\//;

TerminalAlternatives:
	Elements+=TerminalGroup ('|' Elements+=TerminalGroup)*
;

TerminalGroup:
	Elements+=TerminalToken*
;

TerminalToken:
	TerminalTokenElement Cardinality=('?'|'*'|'+')?
;

TerminalTokenElement:
	CharacterRange | TerminalRuleCall | ParenthesizedTerminalElement | AbstractNegatedToken | Wildcard
;

ParenthesizedTerminalElement:
	'(' TerminalAlternatives ')'
;

AbstractNegatedToken:
	NegatedToken | UntilToken
;

NegatedToken:
	'!' ^Terminal=TerminalTokenElement
;

UntilToken:
	'->' ^Terminal=TerminalTokenElement
;

Wildcard:
	{Wildcard} '.'
;

CharacterRange:
	Left=Keyword ('..' Right=Keyword)?
;

EnumRule:
	'enum' Name=ID ('returns' Type=ID)? ':'
		Alternatives=EnumLiterals
	';'
;

EnumLiterals:
	Elements+=EnumLiteralDeclaration ('|' Elements+=EnumLiteralDeclaration)*
;

EnumLiteralDeclaration:
	EnumLiteral=[EnumLiterals|ID] ('=' Literal=Keyword)?
;
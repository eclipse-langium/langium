/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

export const DomainModelTerminals = {
    WS: /\s+/,
    ID: /[_a-zA-Z][\w_]*/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type DomainModelTerminalNames = keyof typeof DomainModelTerminals;

export type DomainModelKeywordNames =
    | "."
    | ":"
    | "datatype"
    | "entity"
    | "extends"
    | "many"
    | "package"
    | "{"
    | "}";

export type DomainModelTokenNames = DomainModelTerminalNames | DomainModelKeywordNames;

export type AbstractElement = PackageDeclaration | Type;

export const AbstractElement = 'AbstractElement';

export function isAbstractElement(item: unknown): item is AbstractElement {
    return reflection.isInstance(item, AbstractElement);
}

export type QualifiedName = string;

export function isQualifiedName(item: unknown): item is QualifiedName {
    return typeof item === 'string';
}

export type Type = DataType | Entity;

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export interface DataType extends langium.AstNode {
    readonly $container: Domainmodel | PackageDeclaration;
    readonly $type: 'DataType';
    name: string;
}

export const DataType = 'DataType';

export function isDataType(item: unknown): item is DataType {
    return reflection.isInstance(item, DataType);
}

export interface Domainmodel extends langium.AstNode {
    readonly $type: 'Domainmodel';
    elements: Array<AbstractElement>;
}

export const Domainmodel = 'Domainmodel';

export function isDomainmodel(item: unknown): item is Domainmodel {
    return reflection.isInstance(item, Domainmodel);
}

export interface Entity extends langium.AstNode {
    readonly $container: Domainmodel | PackageDeclaration;
    readonly $type: 'Entity';
    features: Array<Feature>;
    name: string;
    superType?: langium.Reference<Entity>;
}

export const Entity = 'Entity';

export function isEntity(item: unknown): item is Entity {
    return reflection.isInstance(item, Entity);
}

export interface Feature extends langium.AstNode {
    readonly $container: Entity;
    readonly $type: 'Feature';
    many: boolean;
    name: string;
    type: langium.Reference<Type>;
}

export const Feature = 'Feature';

export function isFeature(item: unknown): item is Feature {
    return reflection.isInstance(item, Feature);
}

export interface PackageDeclaration extends langium.AstNode {
    readonly $container: Domainmodel | PackageDeclaration;
    readonly $type: 'PackageDeclaration';
    elements: Array<AbstractElement>;
    name: QualifiedName;
}

export const PackageDeclaration = 'PackageDeclaration';

export function isPackageDeclaration(item: unknown): item is PackageDeclaration {
    return reflection.isInstance(item, PackageDeclaration);
}

export type DomainModelAstType = {
    AbstractElement: AbstractElement
    DataType: DataType
    Domainmodel: Domainmodel
    Entity: Entity
    Feature: Feature
    PackageDeclaration: PackageDeclaration
    Type: Type
}

export const properties: langium.AstTypeProperties<DomainModelAstType> = langium.deepFreeze({
    AbstractElement: {
        elements: 'elements',
        name: 'name',
    },
    DataType: {
        name: 'name',
    },
    Domainmodel: {
        elements: 'elements',
    },
    Entity: {
        features: 'features',
        name: 'name',
        superType: 'superType',
    },
    Feature: {
        many: 'many',
        name: 'name',
        type: 'type',
    },
    PackageDeclaration: {
        elements: 'elements',
        name: 'name',
    },
    Type: {
        name: 'name',
    },
});

export class DomainModelAstReflection extends langium.AbstractAstReflection {

    readonly AbstractElement = {
        $name: AbstractElement,
        $properties: {
            elements: { name: 'elements', type: 'AbstractElement', kind: 'Containment', defaultValue: [] },
            name: { name: 'name', type: 'QualifiedName', kind: 'Primitive' },
        },
    };
    readonly DataType = {
        $name: DataType,
        $properties: {
            name: { name: 'name', type: 'string', kind: 'Primitive' },
        },
    };
    readonly Domainmodel = {
        $name: Domainmodel,
        $properties: {
            elements: { name: 'elements', type: 'AbstractElement', kind: 'Containment', defaultValue: [] },
        },
    };
    readonly Entity = {
        $name: Entity,
        $properties: {
            features: { name: 'features', type: 'Feature', kind: 'Containment', defaultValue: [] },
            name: { name: 'name', type: 'string', kind: 'Primitive' },
            superType: { name: 'superType', type: 'Entity', kind: 'Reference' },
        },
    };
    readonly Feature = {
        $name: Feature,
        $properties: {
            many: { name: 'many', type: 'boolean', kind: 'Primitive', defaultValue: false },
            name: { name: 'name', type: 'string', kind: 'Primitive' },
            type: { name: 'type', type: 'Type', kind: 'Reference' },
        },
    };
    readonly PackageDeclaration = {
        $name: PackageDeclaration,
        $properties: {
            elements: { name: 'elements', type: 'AbstractElement', kind: 'Containment', defaultValue: [] },
            name: { name: 'name', type: 'QualifiedName', kind: 'Primitive' },
        },
    };
    readonly Type = {
        $name: Type,
        $properties: {
            name: { name: 'name', type: 'string', kind: 'Primitive' },
        },
    };

    getAllTypes(): string[] {
        return [AbstractElement, DataType, Domainmodel, Entity, Feature, PackageDeclaration, Type];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case DataType:
            case Entity: {
                return this.isSubtype(Type, supertype);
            }
            case PackageDeclaration:
            case Type: {
                return this.isSubtype(AbstractElement, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: langium.ReferenceInfo): string {
        // TODO move both methods into the parent class?
        const containerTypeName = refInfo.container.$type;
        const containerTypeMetaData = this.getTypeMetaData(containerTypeName);
        if (containerTypeMetaData === undefined) {
            throw new Error(`${containerTypeName} is not a valid container $type.`);
        }
        const propertyMetaData = containerTypeMetaData.$properties[refInfo.property]; //  as keyof langium.SpecificPropertiesToString<langium.AstNode>
        if (propertyMetaData === undefined) {
            throw new Error(`'${refInfo.property}' is not a valid property of the container $type ${containerTypeName}.`);
        }
        if (propertyMetaData.kind !== 'Reference') {
            throw new Error(`'${refInfo.property}' is no Reference, but ${propertyMetaData.kind}.`);
        }
        return propertyMetaData.type;
    }

    getTypeMetaData(type: string): langium.TypeMetaData | undefined {
        return this[type as keyof DomainModelAstReflection] as (langium.TypeMetaData | undefined);
    }
}

export const reflection = new DomainModelAstReflection();

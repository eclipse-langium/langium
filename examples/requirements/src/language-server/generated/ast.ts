/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

export const RequirementsAndTestsTerminals = {
    WS: /\s+/,
    ID: /[_a-zA-Z][\w_]*/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type RequirementsAndTestsTerminalNames = keyof typeof RequirementsAndTestsTerminals;

export type RequirementsAndTestsKeywordNames =
    | ","
    | ":"
    | "="
    | "applicable"
    | "contact"
    | "environment"
    | "for"
    | "req"
    | "testFile"
    | "tests"
    | "tst";

export type RequirementsAndTestsTokenNames = RequirementsAndTestsTerminalNames | RequirementsAndTestsKeywordNames;

export interface Contact extends langium.AstNode {
    readonly $container: RequirementModel | TestModel;
    readonly $type: 'Contact';
    user_name: string;
}

export const Contact = 'Contact';

export function isContact(item: unknown): item is Contact {
    return reflection.isInstance(item, Contact);
}

export interface Environment extends langium.AstNode {
    readonly $container: RequirementModel;
    readonly $type: 'Environment';
    description: string;
    name: string;
}

export const Environment = 'Environment';

export function isEnvironment(item: unknown): item is Environment {
    return reflection.isInstance(item, Environment);
}

export interface Requirement extends langium.AstNode {
    readonly $container: RequirementModel;
    readonly $type: 'Requirement';
    environments: Array<langium.Reference<Environment>>;
    name: string;
    text: string;
}

export const Requirement = 'Requirement';

export function isRequirement(item: unknown): item is Requirement {
    return reflection.isInstance(item, Requirement);
}

export interface RequirementModel extends langium.AstNode {
    readonly $type: 'RequirementModel';
    contact?: Contact;
    environments: Array<Environment>;
    requirements: Array<Requirement>;
}

export const RequirementModel = 'RequirementModel';

export function isRequirementModel(item: unknown): item is RequirementModel {
    return reflection.isInstance(item, RequirementModel);
}

export interface Test extends langium.AstNode {
    readonly $container: TestModel;
    readonly $type: 'Test';
    environments: Array<langium.Reference<Environment>>;
    name: string;
    requirements: Array<langium.Reference<Requirement>>;
    testFile?: string;
}

export const Test = 'Test';

export function isTest(item: unknown): item is Test {
    return reflection.isInstance(item, Test);
}

export interface TestModel extends langium.AstNode {
    readonly $type: 'TestModel';
    contact?: Contact;
    tests: Array<Test>;
}

export const TestModel = 'TestModel';

export function isTestModel(item: unknown): item is TestModel {
    return reflection.isInstance(item, TestModel);
}

export type RequirementsAndTestsAstType = {
    Contact: Contact
    Environment: Environment
    Requirement: Requirement
    RequirementModel: RequirementModel
    Test: Test
    TestModel: TestModel
}

export const properties: langium.AstTypeProperties<RequirementsAndTestsAstType> = langium.deepFreeze({
    Contact: {
        user_name: 'user_name',
    },
    Environment: {
        description: 'description',
        name: 'name',
    },
    Requirement: {
        environments: 'environments',
        name: 'name',
        text: 'text',
    },
    RequirementModel: {
        contact: 'contact',
        environments: 'environments',
        requirements: 'requirements',
    },
    Test: {
        environments: 'environments',
        name: 'name',
        requirements: 'requirements',
        testFile: 'testFile',
    },
    TestModel: {
        contact: 'contact',
        tests: 'tests',
    },
});

export class RequirementsAndTestsAstReflection extends langium.AbstractAstReflection {

    readonly Contact = {
        $name: Contact,
        $properties: {
            user_name: { name: 'user_name', type: 'string', kind: 'Primitive' },
        },
    };
    readonly Environment = {
        $name: Environment,
        $properties: {
            description: { name: 'description', type: 'string', kind: 'Primitive' },
            name: { name: 'name', type: 'string', kind: 'Primitive' },
        },
    };
    readonly Requirement = {
        $name: Requirement,
        $properties: {
            environments: { name: 'environments', type: 'Environment', kind: 'Reference', defaultValue: [] },
            name: { name: 'name', type: 'string', kind: 'Primitive' },
            text: { name: 'text', type: 'string', kind: 'Primitive' },
        },
    };
    readonly RequirementModel = {
        $name: RequirementModel,
        $properties: {
            contact: { name: 'contact', type: 'Contact', kind: 'Containment' },
            environments: { name: 'environments', type: 'Environment', kind: 'Containment', defaultValue: [] },
            requirements: { name: 'requirements', type: 'Requirement', kind: 'Containment', defaultValue: [] },
        },
    };
    readonly Test = {
        $name: Test,
        $properties: {
            environments: { name: 'environments', type: 'Environment', kind: 'Reference', defaultValue: [] },
            name: { name: 'name', type: 'string', kind: 'Primitive' },
            requirements: { name: 'requirements', type: 'Requirement', kind: 'Reference', defaultValue: [] },
            testFile: { name: 'testFile', type: 'string', kind: 'Primitive' },
        },
    };
    readonly TestModel = {
        $name: TestModel,
        $properties: {
            contact: { name: 'contact', type: 'Contact', kind: 'Containment' },
            tests: { name: 'tests', type: 'Test', kind: 'Containment', defaultValue: [] },
        },
    };

    getAllTypes(): string[] {
        return [Contact, Environment, Requirement, RequirementModel, Test, TestModel];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: langium.ReferenceInfo): string {
        // TODO move both methods into the parent class?
        const containerTypeName = refInfo.container.$type;
        const containerTypeMetaData = this.getTypeMetaData(containerTypeName);
        if (containerTypeMetaData === undefined) {
            throw new Error(`${containerTypeName} is not a valid container $type.`);
        }
        const propertyMetaData = containerTypeMetaData.$properties[refInfo.property]; //  as keyof langium.SpecificPropertiesToString<langium.AstNode>
        if (propertyMetaData === undefined) {
            throw new Error(`'${refInfo.property}' is not a valid property of the container $type ${containerTypeName}.`);
        }
        if (propertyMetaData.kind !== 'Reference') {
            throw new Error(`'${refInfo.property}' is no Reference, but ${propertyMetaData.kind}.`);
        }
        return propertyMetaData.type;
    }

    getTypeMetaData(type: string): langium.TypeMetaData | undefined {
        return this[type as keyof RequirementsAndTestsAstReflection] as (langium.TypeMetaData | undefined);
    }
}

export const reflection = new RequirementsAndTestsAstReflection();

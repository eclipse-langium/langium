/******************************************************************************
 * This file was generated by langium-cli 0.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
// @ts-nocheck
import { createToken, Lexer } from 'chevrotain';
import { LangiumParser, LangiumServices, DatatypeSymbol } from 'langium';
import { StatemachineGrammarAccess } from './grammar-access';
import { Command, Event, State, Statemachine, Transition, } from './ast';

const ID = createToken({ name: 'ID', pattern: /[_a-zA-Z][\w_]*/ });
const INT = createToken({ name: 'INT', pattern: /[0-9]+/ });
const ML_COMMENT = createToken({ name: 'ML_COMMENT', pattern: /\/\*[\s\S]*?\*\//, group: 'hidden' });
const SL_COMMENT = createToken({ name: 'SL_COMMENT', pattern: /\/\/[^\n\r]*/, group: 'hidden' });
const STRING = createToken({ name: 'STRING', pattern: /"[^"]*"|'[^']*'/ });
const WS = createToken({ name: 'WS', pattern: /\s+/, group: Lexer.SKIPPED });
const InitialStateKeyword = createToken({ name: 'InitialStateKeyword', pattern: /initialState/, longer_alt: ID });
const StatemachineKeyword = createToken({ name: 'StatemachineKeyword', pattern: /statemachine/, longer_alt: ID });
const CommandsKeyword = createToken({ name: 'CommandsKeyword', pattern: /commands/, longer_alt: ID });
const ActionsKeyword = createToken({ name: 'ActionsKeyword', pattern: /actions/, longer_alt: ID });
const EventsKeyword = createToken({ name: 'EventsKeyword', pattern: /events/, longer_alt: ID });
const StateKeyword = createToken({ name: 'StateKeyword', pattern: /state/, longer_alt: ID });
const EndKeyword = createToken({ name: 'EndKeyword', pattern: /end/, longer_alt: ID });
const EqualsMoreThanKeyword = createToken({ name: 'EqualsMoreThanKeyword', pattern: /=>/ });
const CurlyCloseKeyword = createToken({ name: 'CurlyCloseKeyword', pattern: /\}/ });
const CurlyOpenKeyword = createToken({ name: 'CurlyOpenKeyword', pattern: /\{/ });

CurlyOpenKeyword.LABEL = "'{'";
CurlyCloseKeyword.LABEL = "'}'";
EqualsMoreThanKeyword.LABEL = "'=>'";
ActionsKeyword.LABEL = "'actions'";
CommandsKeyword.LABEL = "'commands'";
EndKeyword.LABEL = "'end'";
EventsKeyword.LABEL = "'events'";
InitialStateKeyword.LABEL = "'initialState'";
StateKeyword.LABEL = "'state'";
StatemachineKeyword.LABEL = "'statemachine'";
const tokens = [InitialStateKeyword, StatemachineKeyword, CommandsKeyword, ActionsKeyword, EventsKeyword, StateKeyword, EndKeyword, EqualsMoreThanKeyword, CurlyCloseKeyword, CurlyOpenKeyword, ID, INT, ML_COMMENT, SL_COMMENT, STRING, WS];

export class Parser extends LangiumParser {
    readonly grammarAccess: StatemachineGrammarAccess;

    constructor(services: LangiumServices) {
        super(tokens, services);
    }

    Statemachine = this.MAIN_RULE("Statemachine", Statemachine, () => {
        this.initializeElement(this.grammarAccess.Statemachine);
        this.consume(1, StatemachineKeyword, this.grammarAccess.Statemachine.StatemachineKeyword);
        this.consume(2, ID, this.grammarAccess.Statemachine.nameIDRuleCall);
        this.option(1, () => {
            this.consume(3, EventsKeyword, this.grammarAccess.Statemachine.EventsKeyword);
            this.atLeastOne(1, () => {
                this.subrule(1, this.Event, this.grammarAccess.Statemachine.eventsEventRuleCall);
            });
        });
        this.option(2, () => {
            this.consume(4, CommandsKeyword, this.grammarAccess.Statemachine.CommandsKeyword);
            this.atLeastOne(2, () => {
                this.subrule(2, this.Command, this.grammarAccess.Statemachine.commandsCommandRuleCall);
            });
        });
        this.consume(5, InitialStateKeyword, this.grammarAccess.Statemachine.InitialStateKeyword);
        this.consume(6, ID, this.grammarAccess.Statemachine.initStateCrossReference);
        this.many(3, () => {
            this.subrule(3, this.State, this.grammarAccess.Statemachine.statesStateRuleCall);
        });
        return this.construct();
    });

    Event = this.DEFINE_RULE("Event", Event, () => {
        this.initializeElement(this.grammarAccess.Event);
        this.consume(1, ID, this.grammarAccess.Event.nameIDRuleCall);
        return this.construct();
    });

    Command = this.DEFINE_RULE("Command", Command, () => {
        this.initializeElement(this.grammarAccess.Command);
        this.consume(1, ID, this.grammarAccess.Command.nameIDRuleCall);
        return this.construct();
    });

    State = this.DEFINE_RULE("State", State, () => {
        this.initializeElement(this.grammarAccess.State);
        this.consume(1, StateKeyword, this.grammarAccess.State.StateKeyword);
        this.consume(2, ID, this.grammarAccess.State.nameIDRuleCall);
        this.option(1, () => {
            this.consume(3, ActionsKeyword, this.grammarAccess.State.ActionsKeyword);
            this.consume(4, CurlyOpenKeyword, this.grammarAccess.State.CurlyOpenKeyword);
            this.atLeastOne(1, () => {
                this.consume(5, ID, this.grammarAccess.State.actionsCommandCrossReference);
            });
            this.consume(6, CurlyCloseKeyword, this.grammarAccess.State.CurlyCloseKeyword);
        });
        this.many(2, () => {
            this.subrule(1, this.Transition, this.grammarAccess.State.transitionsTransitionRuleCall);
        });
        this.consume(7, EndKeyword, this.grammarAccess.State.EndKeyword);
        return this.construct();
    });

    Transition = this.DEFINE_RULE("Transition", Transition, () => {
        this.initializeElement(this.grammarAccess.Transition);
        this.consume(1, ID, this.grammarAccess.Transition.eventEventCrossReference);
        this.consume(2, EqualsMoreThanKeyword, this.grammarAccess.Transition.EqualsMoreThanKeyword);
        this.consume(3, ID, this.grammarAccess.Transition.stateStateCrossReference);
        return this.construct();
    });

}

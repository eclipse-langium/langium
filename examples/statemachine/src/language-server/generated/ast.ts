/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

export const StatemachineTerminals = {
    WS: /\s+/,
    ID: /[_a-zA-Z][\w_]*/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type StatemachineTerminalNames = keyof typeof StatemachineTerminals;

export type StatemachineKeywordNames =
    | "=>"
    | "actions"
    | "commands"
    | "end"
    | "events"
    | "initialState"
    | "state"
    | "statemachine"
    | "{"
    | "}";

export type StatemachineTokenNames = StatemachineTerminalNames | StatemachineKeywordNames;

export interface Command extends langium.AstNode {
    readonly $container: Statemachine;
    readonly $type: 'Command';
    name: string;
}

export const Command = 'Command';

export function isCommand(item: unknown): item is Command {
    return reflection.isInstance(item, Command);
}

/** An event is the trigger for a transition */
export interface Event extends langium.AstNode {
    readonly $container: Statemachine;
    readonly $type: 'Event';
    name: string;
}

export const Event = 'Event';

export function isEvent(item: unknown): item is Event {
    return reflection.isInstance(item, Event);
}

/** A description of the status of a system */
export interface State extends langium.AstNode {
    readonly $container: Statemachine;
    readonly $type: 'State';
    actions: Array<langium.Reference<Command>>;
    name: string;
    /** The transitions to other states that can take place from the current one */
    transitions: Array<Transition>;
}

export const State = 'State';

export function isState(item: unknown): item is State {
    return reflection.isInstance(item, State);
}

/** A textual represntation of a state machine */
export interface Statemachine extends langium.AstNode {
    readonly $type: 'Statemachine';
    commands: Array<Command>;
    /** The list of recognized event names */
    events: Array<Event>;
    /** The starting state for the machine */
    init: langium.Reference<State>;
    /** The name of the machine */
    name: string;
    /** Definitions of available states */
    states: Array<State>;
}

export const Statemachine = 'Statemachine';

export function isStatemachine(item: unknown): item is Statemachine {
    return reflection.isInstance(item, Statemachine);
}

/** A change from one state to another */
export interface Transition extends langium.AstNode {
    readonly $container: State;
    readonly $type: 'Transition';
    /** The event triggering the transition */
    event: langium.Reference<Event>;
    /** The target state */
    state: langium.Reference<State>;
}

export const Transition = 'Transition';

export function isTransition(item: unknown): item is Transition {
    return reflection.isInstance(item, Transition);
}

export type StatemachineAstType = {
    Command: Command
    Event: Event
    State: State
    Statemachine: Statemachine
    Transition: Transition
}

export const properties: langium.AstTypeProperties<StatemachineAstType> = langium.deepFreeze({
    Command: {
        $name: Command,
        name: 'name',
    },
    Event: {
        $name: Event,
        name: 'name',
    },
    State: {
        $name: State,
        actions: 'actions',
        name: 'name',
        transitions: 'transitions',
    },
    Statemachine: {
        $name: Statemachine,
        commands: 'commands',
        events: 'events',
        init: 'init',
        name: 'name',
        states: 'states',
    },
    Transition: {
        $name: Transition,
        event: 'event',
        state: 'state',
    },
});

export class StatemachineAstReflection extends langium.AbstractAstReflection {

    readonly Command = {
        $name: Command,
        $properties: {
            name: { name: 'name', type: 'string', kind: 'Primitive' },
        },
    };
    readonly Event = {
        $name: Event,
        $properties: {
            name: { name: 'name', type: 'string', kind: 'Primitive' },
        },
    };
    readonly State = {
        $name: State,
        $properties: {
            actions: { name: 'actions', type: 'Command', kind: 'Reference', defaultValue: [] },
            name: { name: 'name', type: 'string', kind: 'Primitive' },
            transitions: { name: 'transitions', type: 'Transition', kind: 'Containment', defaultValue: [] },
        },
    };
    readonly Statemachine = {
        $name: Statemachine,
        $properties: {
            commands: { name: 'commands', type: 'Command', kind: 'Containment', defaultValue: [] },
            events: { name: 'events', type: 'Event', kind: 'Containment', defaultValue: [] },
            init: { name: 'init', type: 'State', kind: 'Reference' },
            name: { name: 'name', type: 'string', kind: 'Primitive' },
            states: { name: 'states', type: 'State', kind: 'Containment', defaultValue: [] },
        },
    };
    readonly Transition = {
        $name: Transition,
        $properties: {
            event: { name: 'event', type: 'Event', kind: 'Reference' },
            state: { name: 'state', type: 'State', kind: 'Reference' },
        },
    };

    getAllTypes(): string[] {
        return [Command, Event, State, Statemachine, Transition];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: langium.ReferenceInfo): string {
        // TODO move both methods into the parent class?
        const containerTypeName = refInfo.container.$type;
        const containerTypeMetaData = this.getTypeMetaData(containerTypeName);
        if (containerTypeMetaData === undefined) {
            throw new Error(`${containerTypeName} is not a valid container $type.`);
        }
        const propertyMetaData = containerTypeMetaData.$properties[refInfo.property]; //  as keyof langium.SpecificPropertiesToString<langium.AstNode>
        if (propertyMetaData === undefined) {
            throw new Error(`'${refInfo.property}' is not a valid property of the container $type ${containerTypeName}.`);
        }
        if (propertyMetaData.kind !== 'Reference') {
            throw new Error(`'${refInfo.property}' is no Reference, but ${propertyMetaData.kind}.`);
        }
        return propertyMetaData.type;
    }

    getTypeMetaData(type: string): langium.TypeMetaData | undefined {
        return this[type as keyof StatemachineAstReflection] as (langium.TypeMetaData | undefined);
    }
}

export const reflection = new StatemachineAstReflection();

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

import { CompositeGeneratorNode, GeneratorNode, getAllReachableRules, Grammar, GrammarAST, NL, stream, streamAllContents } from 'langium';
import fs from 'fs-extra';
import path from 'path';
import * as readline from 'readline';
import chalk from 'chalk';

//eslint-disable-next-line @typescript-eslint/no-explicit-any
export function log(level: 'log' | 'warn' | 'error', options: { watch: boolean }, message: string, ...args: any[]): void {
    if (options.watch) {
        console[level](getTime() + message, ...args);
    } else {
        console[level](message, ...args);
    }
}

let start = process.hrtime();

export function elapsedTime(): string {
    const elapsed = process.hrtime(start)[1] / 1000000; // divide by a million to get nano to milli
    start = process.hrtime(); // reset the timer
    return elapsed.toFixed();
}

export function getTime(): string {
    const date = new Date();
    return `[${chalk.gray(`${padZeroes(date.getHours())}:${padZeroes(date.getMinutes())}:${padZeroes(date.getSeconds())}`)}] `;
}

function padZeroes(i: number): string {
    return i.toString().padStart(2, '0');
}

function getLangiumCliVersion(): string {
    const ownPackagePath = path.resolve(__dirname, '..', '..', 'package.json');
    const pack = fs.readJsonSync(ownPackagePath, { encoding: 'utf-8' });
    return pack.version;
}

function getGeneratedHeader(): GeneratorNode {
    const node = new CompositeGeneratorNode();
    node.contents.push(
        '/******************************************************************************', NL,
        ` * This file was generated by langium-cli ${cliVersion}.`, NL,
        ' * DO NOT EDIT MANUALLY!', NL,
        ' ******************************************************************************/', NL, NL
    );
    return node;
}

export function collectKeywords(grammar: Grammar): string[] {
    const keywords = new Set<string>();
    const reachableRules = getAllReachableRules(grammar, false);

    for (const keyword of stream(reachableRules)
        .filter(GrammarAST.isParserRule)
        .flatMap(rule => streamAllContents(rule).filter(GrammarAST.isKeyword))) {
        keywords.add(keyword.value);
    }

    return Array.from(keywords).sort((a, b) => a.localeCompare(b));
}

export function getUserInput(text: string): Promise<string> {
    return new Promise(resolve => {
        const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
        rl.question(text, answer => {
            resolve(answer);
            rl.close();
        });
    });
}

export async function getUserChoice<R extends string>(text: string, values: R[], defaultValue: R, lowerCase = true): Promise<R> {
    const prompt = text + ' ' + values.map(v => v === defaultValue ? `[${v}]` : v).join('/') + ': ';
    const answer = await getUserInput(prompt);
    if (!answer) {
        return defaultValue;
    }
    const lcAnswer = lowerCase ? answer.toLowerCase() : answer;
    for (const value of values) {
        if (value.startsWith(lcAnswer)) {
            return value;
        }
    }
    return defaultValue;
}

export const cliVersion = getLangiumCliVersion();
export const generatedHeader = getGeneratedHeader();
export const schema = fs.readJson(path.resolve(__dirname, '../../langium-config-schema.json'), { encoding: 'utf-8' });

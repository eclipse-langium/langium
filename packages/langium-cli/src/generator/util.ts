/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

import * as langium from 'langium';
import { CompositeGeneratorNode, GeneratorNode, NL, stream } from 'langium';
import fs from 'fs-extra';
import path from 'path';
import * as readline from 'readline';
import type { GenerateOptions } from '../generate';

//eslint-disable-next-line @typescript-eslint/no-explicit-any
export function log(level: 'log' | 'warn' | 'error', options: GenerateOptions, message: string, ...args: any[]): void {
    if (options.watch) {
        console[level](getTime() + message, ...args);
    } else {
        console[level](message, ...args);
    }
}

let start = process.hrtime();

export function elapsedTime(): string {
    const elapsed = process.hrtime(start)[1] / 1000000; // divide by a million to get nano to milli
    start = process.hrtime(); // reset the timer
    return elapsed.toFixed();
}

export function getTime(): string {
    const date = new Date();
    return `[${`${padZeroes(date.getHours())}:${padZeroes(date.getMinutes())}:${padZeroes(date.getSeconds())}`.gray}] `;
}

function padZeroes(i: number): string {
    return i.toString().padStart(2, '0');
}

function getLangiumCliVersion(): string {
    const ownPackagePath = path.resolve(__dirname, '..', '..', 'package.json');
    const pack = fs.readJsonSync(ownPackagePath, { encoding: 'utf-8' });
    return pack.version;
}

function getGeneratedHeader(): GeneratorNode {
    const node = new CompositeGeneratorNode();
    node.contents.push(
        '/******************************************************************************', NL,
        ` * This file was generated by langium-cli ${cliVersion}.`, NL,
        ' * DO NOT EDIT MANUALLY!', NL,
        ' ******************************************************************************/', NL, NL
    );
    return node;
}

export function collectKeywords(grammar: langium.Grammar): string[] {
    const keywords = new Set<string>();

    for (const rule of stream(grammar.rules).filter(langium.isParserRule)) {
        collectElementKeywords(rule.alternatives, keywords);
    }

    return Array.from(keywords).sort((a, b) => a.localeCompare(b));
}

function collectElementKeywords(element: langium.AbstractElement, keywords: Set<string>) {
    if (langium.isAlternatives(element) || langium.isGroup(element) || langium.isUnorderedGroup(element)) {
        for (const item of element.elements) {
            collectElementKeywords(item, keywords);
        }
    } else if (langium.isAssignment(element)) {
        collectElementKeywords(element.terminal, keywords);
    } else if (langium.isKeyword(element)) {
        keywords.add(element.value);
    }
}

export function getUserInput(text: string): Promise<string> {
    return new Promise(resolve => {
        const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
        rl.question(text, answer => {
            resolve(answer);
            rl.close();
        });
    });
}

export async function getUserChoice<R extends string>(text: string, values: R[], defaultValue: R, lowerCase = true): Promise<R> {
    const prompt = text + ' ' + values.map(v => v === defaultValue ? `[${v}]` : v).join('/') + ': ';
    const answer = await getUserInput(prompt);
    if (!answer) {
        return defaultValue;
    }
    const lcAnswer = lowerCase ? answer.toLowerCase() : answer;
    for (const value of values) {
        if (value.startsWith(lcAnswer)) {
            return value;
        }
    }
    return defaultValue;
}

export const cliVersion = getLangiumCliVersion();
export const generatedHeader = getGeneratedHeader();
export const schema = fs.readJson(path.resolve(__dirname, '../../langium-config-schema.json'), { encoding: 'utf-8' });

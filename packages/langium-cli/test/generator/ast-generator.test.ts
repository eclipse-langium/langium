/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
import { describe, expect, test } from 'vitest';
import { createLangiumGrammarServices, EmptyFileSystem, Grammar, normalizeEOL } from 'langium';
import { parseHelper } from 'langium/test';
import { LangiumConfig, RelativePath } from '../../src/package';
import { generateAst } from '../../src/generator/ast-generator';

const services = createLangiumGrammarServices(EmptyFileSystem);

describe('Types generator', () => {

    test('should generate checker functions for datatype rules', async () => {
        const result = (await parseHelper<Grammar>(services.grammar)(TEST_GRAMMAR)).parseResult;
        const config: LangiumConfig = {
            [RelativePath]: './',
            projectName: 'test',
            languages: []
        };
        const typesFileContent = generateAst(services.grammar, [result.value], config);
        expect(typesFileContent).toEqual(EXPECTED_AST_FILE);
    });
});

const TEST_GRAMMAR = `
grammar Arithmetics

A returns string:
    'a';

AB returns string:
    A | 'b';

ABC returns string:
    AB | ID;

hidden terminal WS: /\\s+/;
terminal ID: /[_a-zA-Z][\\w_]*/;

hidden terminal ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//;
hidden terminal SL_COMMENT: /\\/\\/[^\\n\\r]*/;
`;

const EXPECTED_AST_FILE = normalizeEOL(`/******************************************************************************
 * This file was generated by langium-cli 1.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, ReferenceInfo, TypeMetaData } from 'langium';

export type A = 'a';
export function isA(item: string): item is A {
    return item === 'a';
}

export type AB = 'b' | A;
export function isAB(item: string): item is AB {
    return isA(item) || item === 'b';
}

export type ABC = AB | string;
export function isABC(item: string): item is ABC {
    return isAB(item) || /[_a-zA-Z][\\w_]*/.test(item);
}

export type testAstType = {
}

export class testAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return [];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = \`\${refInfo.container.$type}:\${refInfo.property}\`;
        switch (referenceId) {
            default: {
                throw new Error(\`\${referenceId} is not a valid reference id.\`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new testAstReflection();
`);

/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from '../../syntax-tree.js';

export const LangiumGrammarTerminals = {
    ID: /\^?[_a-zA-Z][\w_]*/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    NUMBER: /NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity)/,
    RegexLiteral: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\/[a-z]*/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type LangiumGrammarTerminalNames = keyof typeof LangiumGrammarTerminals;

export type LangiumGrammarKeywordNames =
    | "!"
    | "&"
    | "("
    | ")"
    | "*"
    | "+"
    | "+="
    | ","
    | "->"
    | "."
    | ".."
    | ":"
    | ";"
    | "<"
    | "="
    | "=>"
    | ">"
    | "?"
    | "?!"
    | "?<!"
    | "?<="
    | "?="
    | "@"
    | "Date"
    | "EOF"
    | "["
    | "]"
    | "assoc"
    | "bigint"
    | "boolean"
    | "current"
    | "entry"
    | "extends"
    | "false"
    | "fragment"
    | "grammar"
    | "hidden"
    | "import"
    | "infer"
    | "infers"
    | "infix"
    | "interface"
    | "left"
    | "number"
    | "on"
    | "returns"
    | "right"
    | "string"
    | "terminal"
    | "true"
    | "type"
    | "with"
    | "{"
    | "|"
    | "}";

export type LangiumGrammarTokenNames = LangiumGrammarTerminalNames | LangiumGrammarKeywordNames;

export type AbstractRule = InfixRule | ParserRule | TerminalRule;

export const AbstractRule = 'AbstractRule';

export function isAbstractRule(item: unknown): item is AbstractRule {
    return reflection.isInstance(item, AbstractRule);
}

export type AbstractType = InferredType | InfixRule | Interface | ParserRule | Type;

export const AbstractType = 'AbstractType';

export function isAbstractType(item: unknown): item is AbstractType {
    return reflection.isInstance(item, AbstractType);
}

export type Associativity = 'left' | 'right';

export function isAssociativity(item: unknown): item is Associativity {
    return item === 'left' || item === 'right';
}

export type Condition = BooleanLiteral | Conjunction | Disjunction | Negation | ParameterReference;

export const Condition = 'Condition';

export function isCondition(item: unknown): item is Condition {
    return reflection.isInstance(item, Condition);
}

export type FeatureName = 'assoc' | 'current' | 'entry' | 'extends' | 'false' | 'fragment' | 'grammar' | 'hidden' | 'import' | 'infer' | 'infers' | 'infix' | 'interface' | 'left' | 'on' | 'returns' | 'right' | 'terminal' | 'true' | 'type' | 'with' | PrimitiveType | string;

export function isFeatureName(item: unknown): item is FeatureName {
    return isPrimitiveType(item) || item === 'infix' || item === 'on' || item === 'right' || item === 'left' || item === 'assoc' || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\^?[_a-zA-Z][\w_]*/.test(item)));
}

export type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';

export function isPrimitiveType(item: unknown): item is PrimitiveType {
    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';
}

export type TypeDefinition = ArrayType | ReferenceType | SimpleType | UnionType;

export const TypeDefinition = 'TypeDefinition';

export function isTypeDefinition(item: unknown): item is TypeDefinition {
    return reflection.isInstance(item, TypeDefinition);
}

export type ValueLiteral = ArrayLiteral | BooleanLiteral | NumberLiteral | StringLiteral;

export const ValueLiteral = 'ValueLiteral';

export function isValueLiteral(item: unknown): item is ValueLiteral {
    return reflection.isInstance(item, ValueLiteral);
}

export interface AbstractElement extends langium.AstNode {
    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'EndOfFile' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';
    cardinality?: '*' | '+' | '?';
    lookahead?: '?!' | '?<!' | '?<=' | '?=';
}

export const AbstractElement = 'AbstractElement';

export function isAbstractElement(item: unknown): item is AbstractElement {
    return reflection.isInstance(item, AbstractElement);
}

export interface ArrayLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'ArrayLiteral';
    elements: Array<ValueLiteral>;
}

export const ArrayLiteral = 'ArrayLiteral';

export function isArrayLiteral(item: unknown): item is ArrayLiteral {
    return reflection.isInstance(item, ArrayLiteral);
}

export interface ArrayType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ArrayType';
    elementType: TypeDefinition;
}

export const ArrayType = 'ArrayType';

export function isArrayType(item: unknown): item is ArrayType {
    return reflection.isInstance(item, ArrayType);
}

export interface BooleanLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | Conjunction | Disjunction | Group | NamedArgument | Negation | TypeAttribute;
    readonly $type: 'BooleanLiteral';
    true: boolean;
}

export const BooleanLiteral = 'BooleanLiteral';

export function isBooleanLiteral(item: unknown): item is BooleanLiteral {
    return reflection.isInstance(item, BooleanLiteral);
}

export interface Conjunction extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Conjunction';
    left: Condition;
    right: Condition;
}

export const Conjunction = 'Conjunction';

export function isConjunction(item: unknown): item is Conjunction {
    return reflection.isInstance(item, Conjunction);
}

export interface Disjunction extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Disjunction';
    left: Condition;
    right: Condition;
}

export const Disjunction = 'Disjunction';

export function isDisjunction(item: unknown): item is Disjunction {
    return reflection.isInstance(item, Disjunction);
}

export interface Grammar extends langium.AstNode {
    readonly $type: 'Grammar';
    imports: Array<GrammarImport>;
    interfaces: Array<Interface>;
    isDeclared: boolean;
    name?: string;
    rules: Array<AbstractRule>;
    types: Array<Type>;
}

export const Grammar = 'Grammar';

export function isGrammar(item: unknown): item is Grammar {
    return reflection.isInstance(item, Grammar);
}

export interface GrammarImport extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'GrammarImport';
    path: string;
}

export const GrammarImport = 'GrammarImport';

export function isGrammarImport(item: unknown): item is GrammarImport {
    return reflection.isInstance(item, GrammarImport);
}

export interface InferredType extends langium.AstNode {
    readonly $container: Action | ParserRule;
    readonly $type: 'InferredType';
    name: string;
}

export const InferredType = 'InferredType';

export function isInferredType(item: unknown): item is InferredType {
    return reflection.isInstance(item, InferredType);
}

export interface InfixRule extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'InfixRule';
    call: RuleCall;
    name: string;
    operators: InfixRuleOperators;
    parameters: Array<Parameter>;
}

export const InfixRule = 'InfixRule';

export function isInfixRule(item: unknown): item is InfixRule {
    return reflection.isInstance(item, InfixRule);
}

export interface InfixRuleOperatorList extends langium.AstNode {
    readonly $container: InfixRuleOperators;
    readonly $type: 'InfixRuleOperatorList';
    associativity?: Associativity;
    operators: Array<Keyword>;
}

export const InfixRuleOperatorList = 'InfixRuleOperatorList';

export function isInfixRuleOperatorList(item: unknown): item is InfixRuleOperatorList {
    return reflection.isInstance(item, InfixRuleOperatorList);
}

export interface InfixRuleOperators extends langium.AstNode {
    readonly $container: InfixRule;
    readonly $type: 'InfixRuleOperators';
    precedences: Array<InfixRuleOperatorList>;
}

export const InfixRuleOperators = 'InfixRuleOperators';

export function isInfixRuleOperators(item: unknown): item is InfixRuleOperators {
    return reflection.isInstance(item, InfixRuleOperators);
}

export interface Interface extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'Interface';
    attributes: Array<TypeAttribute>;
    name: string;
    superTypes: Array<langium.Reference<AbstractType>>;
}

export const Interface = 'Interface';

export function isInterface(item: unknown): item is Interface {
    return reflection.isInstance(item, Interface);
}

export interface NamedArgument extends langium.AstNode {
    readonly $container: RuleCall;
    readonly $type: 'NamedArgument';
    calledByName: boolean;
    parameter?: langium.Reference<Parameter>;
    value: Condition;
}

export const NamedArgument = 'NamedArgument';

export function isNamedArgument(item: unknown): item is NamedArgument {
    return reflection.isInstance(item, NamedArgument);
}

export interface Negation extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Negation';
    value: Condition;
}

export const Negation = 'Negation';

export function isNegation(item: unknown): item is Negation {
    return reflection.isInstance(item, Negation);
}

export interface NumberLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'NumberLiteral';
    value: number;
}

export const NumberLiteral = 'NumberLiteral';

export function isNumberLiteral(item: unknown): item is NumberLiteral {
    return reflection.isInstance(item, NumberLiteral);
}

export interface Parameter extends langium.AstNode {
    readonly $container: InfixRule | ParserRule;
    readonly $type: 'Parameter';
    name: string;
}

export const Parameter = 'Parameter';

export function isParameter(item: unknown): item is Parameter {
    return reflection.isInstance(item, Parameter);
}

export interface ParameterReference extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'ParameterReference';
    parameter: langium.Reference<Parameter>;
}

export const ParameterReference = 'ParameterReference';

export function isParameterReference(item: unknown): item is ParameterReference {
    return reflection.isInstance(item, ParameterReference);
}

export interface ParserRule extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'ParserRule';
    dataType?: PrimitiveType;
    definition: AbstractElement;
    entry: boolean;
    fragment: boolean;
    inferredType?: InferredType;
    name: string;
    parameters: Array<Parameter>;
    returnType?: langium.Reference<AbstractType>;
}

export const ParserRule = 'ParserRule';

export function isParserRule(item: unknown): item is ParserRule {
    return reflection.isInstance(item, ParserRule);
}

export interface ReferenceType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ReferenceType';
    referenceType: TypeDefinition;
}

export const ReferenceType = 'ReferenceType';

export function isReferenceType(item: unknown): item is ReferenceType {
    return reflection.isInstance(item, ReferenceType);
}

export interface ReturnType extends langium.AstNode {
    readonly $container: TerminalRule;
    readonly $type: 'ReturnType';
    name: PrimitiveType | string;
}

export const ReturnType = 'ReturnType';

export function isReturnType(item: unknown): item is ReturnType {
    return reflection.isInstance(item, ReturnType);
}

export interface SimpleType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'SimpleType';
    primitiveType?: PrimitiveType;
    stringType?: string;
    typeRef?: langium.Reference<AbstractType>;
}

export const SimpleType = 'SimpleType';

export function isSimpleType(item: unknown): item is SimpleType {
    return reflection.isInstance(item, SimpleType);
}

export interface StringLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'StringLiteral';
    value: string;
}

export const StringLiteral = 'StringLiteral';

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, StringLiteral);
}

export interface TerminalRule extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'TerminalRule';
    definition: AbstractElement;
    fragment: boolean;
    hidden: boolean;
    name: string;
    type?: ReturnType;
}

export const TerminalRule = 'TerminalRule';

export function isTerminalRule(item: unknown): item is TerminalRule {
    return reflection.isInstance(item, TerminalRule);
}

export interface Type extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'Type';
    name: string;
    type: TypeDefinition;
}

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export interface TypeAttribute extends langium.AstNode {
    readonly $container: Interface;
    readonly $type: 'TypeAttribute';
    defaultValue?: ValueLiteral;
    isOptional: boolean;
    name: FeatureName;
    type: TypeDefinition;
}

export const TypeAttribute = 'TypeAttribute';

export function isTypeAttribute(item: unknown): item is TypeAttribute {
    return reflection.isInstance(item, TypeAttribute);
}

export interface UnionType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'UnionType';
    types: Array<TypeDefinition>;
}

export const UnionType = 'UnionType';

export function isUnionType(item: unknown): item is UnionType {
    return reflection.isInstance(item, UnionType);
}

export interface Action extends AbstractElement {
    readonly $type: 'Action';
    feature?: FeatureName;
    inferredType?: InferredType;
    operator?: '+=' | '=';
    type?: langium.Reference<AbstractType>;
}

export const Action = 'Action';

export function isAction(item: unknown): item is Action {
    return reflection.isInstance(item, Action);
}

export interface Alternatives extends AbstractElement {
    readonly $type: 'Alternatives';
    elements: Array<AbstractElement>;
}

export const Alternatives = 'Alternatives';

export function isAlternatives(item: unknown): item is Alternatives {
    return reflection.isInstance(item, Alternatives);
}

export interface Assignment extends AbstractElement {
    readonly $type: 'Assignment';
    feature: FeatureName;
    operator: '+=' | '=' | '?=';
    predicate?: '->' | '=>';
    terminal: AbstractElement;
}

export const Assignment = 'Assignment';

export function isAssignment(item: unknown): item is Assignment {
    return reflection.isInstance(item, Assignment);
}

export interface CharacterRange extends AbstractElement {
    readonly $type: 'CharacterRange';
    left: Keyword;
    right?: Keyword;
}

export const CharacterRange = 'CharacterRange';

export function isCharacterRange(item: unknown): item is CharacterRange {
    return reflection.isInstance(item, CharacterRange);
}

export interface CrossReference extends AbstractElement {
    readonly $type: 'CrossReference';
    deprecatedSyntax: boolean;
    terminal?: AbstractElement;
    type: langium.Reference<AbstractType>;
}

export const CrossReference = 'CrossReference';

export function isCrossReference(item: unknown): item is CrossReference {
    return reflection.isInstance(item, CrossReference);
}

export interface EndOfFile extends AbstractElement {
    readonly $type: 'EndOfFile';
}

export const EndOfFile = 'EndOfFile';

export function isEndOfFile(item: unknown): item is EndOfFile {
    return reflection.isInstance(item, EndOfFile);
}

export interface Group extends AbstractElement {
    readonly $type: 'Group';
    elements: Array<AbstractElement>;
    guardCondition?: Condition;
    predicate?: '->' | '=>';
}

export const Group = 'Group';

export function isGroup(item: unknown): item is Group {
    return reflection.isInstance(item, Group);
}

export interface Keyword extends AbstractElement {
    readonly $container: CharacterRange | InfixRuleOperatorList;
    readonly $type: 'Keyword';
    predicate?: '->' | '=>';
    value: string;
}

export const Keyword = 'Keyword';

export function isKeyword(item: unknown): item is Keyword {
    return reflection.isInstance(item, Keyword);
}

export interface NegatedToken extends AbstractElement {
    readonly $type: 'NegatedToken';
    terminal: AbstractElement;
}

export const NegatedToken = 'NegatedToken';

export function isNegatedToken(item: unknown): item is NegatedToken {
    return reflection.isInstance(item, NegatedToken);
}

export interface RegexToken extends AbstractElement {
    readonly $type: 'RegexToken';
    regex: string;
}

export const RegexToken = 'RegexToken';

export function isRegexToken(item: unknown): item is RegexToken {
    return reflection.isInstance(item, RegexToken);
}

export interface RuleCall extends AbstractElement {
    readonly $container: InfixRule;
    readonly $type: 'RuleCall';
    arguments: Array<NamedArgument>;
    predicate?: '->' | '=>';
    rule: langium.Reference<AbstractRule>;
}

export const RuleCall = 'RuleCall';

export function isRuleCall(item: unknown): item is RuleCall {
    return reflection.isInstance(item, RuleCall);
}

export interface TerminalAlternatives extends AbstractElement {
    readonly $type: 'TerminalAlternatives';
    elements: Array<AbstractElement>;
}

export const TerminalAlternatives = 'TerminalAlternatives';

export function isTerminalAlternatives(item: unknown): item is TerminalAlternatives {
    return reflection.isInstance(item, TerminalAlternatives);
}

export interface TerminalGroup extends AbstractElement {
    readonly $type: 'TerminalGroup';
    elements: Array<AbstractElement>;
}

export const TerminalGroup = 'TerminalGroup';

export function isTerminalGroup(item: unknown): item is TerminalGroup {
    return reflection.isInstance(item, TerminalGroup);
}

export interface TerminalRuleCall extends AbstractElement {
    readonly $type: 'TerminalRuleCall';
    rule: langium.Reference<TerminalRule>;
}

export const TerminalRuleCall = 'TerminalRuleCall';

export function isTerminalRuleCall(item: unknown): item is TerminalRuleCall {
    return reflection.isInstance(item, TerminalRuleCall);
}

export interface UnorderedGroup extends AbstractElement {
    readonly $type: 'UnorderedGroup';
    elements: Array<AbstractElement>;
}

export const UnorderedGroup = 'UnorderedGroup';

export function isUnorderedGroup(item: unknown): item is UnorderedGroup {
    return reflection.isInstance(item, UnorderedGroup);
}

export interface UntilToken extends AbstractElement {
    readonly $type: 'UntilToken';
    terminal: AbstractElement;
}

export const UntilToken = 'UntilToken';

export function isUntilToken(item: unknown): item is UntilToken {
    return reflection.isInstance(item, UntilToken);
}

export interface Wildcard extends AbstractElement {
    readonly $type: 'Wildcard';
}

export const Wildcard = 'Wildcard';

export function isWildcard(item: unknown): item is Wildcard {
    return reflection.isInstance(item, Wildcard);
}

export type LangiumGrammarAstType = {
    AbstractElement: AbstractElement
    AbstractRule: AbstractRule
    AbstractType: AbstractType
    Action: Action
    Alternatives: Alternatives
    ArrayLiteral: ArrayLiteral
    ArrayType: ArrayType
    Assignment: Assignment
    BooleanLiteral: BooleanLiteral
    CharacterRange: CharacterRange
    Condition: Condition
    Conjunction: Conjunction
    CrossReference: CrossReference
    Disjunction: Disjunction
    EndOfFile: EndOfFile
    Grammar: Grammar
    GrammarImport: GrammarImport
    Group: Group
    InferredType: InferredType
    InfixRule: InfixRule
    InfixRuleOperatorList: InfixRuleOperatorList
    InfixRuleOperators: InfixRuleOperators
    Interface: Interface
    Keyword: Keyword
    NamedArgument: NamedArgument
    NegatedToken: NegatedToken
    Negation: Negation
    NumberLiteral: NumberLiteral
    Parameter: Parameter
    ParameterReference: ParameterReference
    ParserRule: ParserRule
    ReferenceType: ReferenceType
    RegexToken: RegexToken
    ReturnType: ReturnType
    RuleCall: RuleCall
    SimpleType: SimpleType
    StringLiteral: StringLiteral
    TerminalAlternatives: TerminalAlternatives
    TerminalGroup: TerminalGroup
    TerminalRule: TerminalRule
    TerminalRuleCall: TerminalRuleCall
    Type: Type
    TypeAttribute: TypeAttribute
    TypeDefinition: TypeDefinition
    UnionType: UnionType
    UnorderedGroup: UnorderedGroup
    UntilToken: UntilToken
    ValueLiteral: ValueLiteral
    Wildcard: Wildcard
}

export class LangiumGrammarAstReflection extends langium.AbstractAstReflection {
    override readonly types = {
        AbstractElement: {
            name: AbstractElement,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                }
            },
            superTypes: [],
            // Property name constants
            _cardinality: 'cardinality',
            _lookahead: 'lookahead'
        },
        Action: {
            name: Action,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                feature: {
                    name: 'feature'
                },
                inferredType: {
                    name: 'inferredType'
                },
                lookahead: {
                    name: 'lookahead'
                },
                operator: {
                    name: 'operator'
                },
                type: {
                    name: 'type',
                    referenceType: 'AbstractType'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _feature: 'feature',
            _inferredType: 'inferredType',
            _lookahead: 'lookahead',
            _operator: 'operator',
            _type: 'type'
        },
        Alternatives: {
            name: Alternatives,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                elements: {
                    name: 'elements',
                    defaultValue: []
                },
                lookahead: {
                    name: 'lookahead'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _elements: 'elements',
            _lookahead: 'lookahead'
        },
        ArrayLiteral: {
            name: ArrayLiteral,
            properties: {
                elements: {
                    name: 'elements',
                    defaultValue: []
                }
            },
            superTypes: ['ValueLiteral'],
            // Property name constants
            _elements: 'elements'
        },
        ArrayType: {
            name: ArrayType,
            properties: {
                elementType: {
                    name: 'elementType'
                }
            },
            superTypes: ['TypeDefinition'],
            // Property name constants
            _elementType: 'elementType'
        },
        Assignment: {
            name: Assignment,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                feature: {
                    name: 'feature'
                },
                lookahead: {
                    name: 'lookahead'
                },
                operator: {
                    name: 'operator'
                },
                predicate: {
                    name: 'predicate'
                },
                terminal: {
                    name: 'terminal'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _feature: 'feature',
            _lookahead: 'lookahead',
            _operator: 'operator',
            _predicate: 'predicate',
            _terminal: 'terminal'
        },
        BooleanLiteral: {
            name: BooleanLiteral,
            properties: {
                true: {
                    name: 'true',
                    defaultValue: false
                }
            },
            superTypes: ['Condition', 'ValueLiteral'],
            // Property name constants
            _true: 'true'
        },
        CharacterRange: {
            name: CharacterRange,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                left: {
                    name: 'left'
                },
                lookahead: {
                    name: 'lookahead'
                },
                right: {
                    name: 'right'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _left: 'left',
            _lookahead: 'lookahead',
            _right: 'right'
        },
        Conjunction: {
            name: Conjunction,
            properties: {
                left: {
                    name: 'left'
                },
                right: {
                    name: 'right'
                }
            },
            superTypes: ['Condition'],
            // Property name constants
            _left: 'left',
            _right: 'right'
        },
        CrossReference: {
            name: CrossReference,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                deprecatedSyntax: {
                    name: 'deprecatedSyntax',
                    defaultValue: false
                },
                lookahead: {
                    name: 'lookahead'
                },
                terminal: {
                    name: 'terminal'
                },
                type: {
                    name: 'type',
                    referenceType: 'AbstractType'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _deprecatedSyntax: 'deprecatedSyntax',
            _lookahead: 'lookahead',
            _terminal: 'terminal',
            _type: 'type'
        },
        Disjunction: {
            name: Disjunction,
            properties: {
                left: {
                    name: 'left'
                },
                right: {
                    name: 'right'
                }
            },
            superTypes: ['Condition'],
            // Property name constants
            _left: 'left',
            _right: 'right'
        },
        EndOfFile: {
            name: EndOfFile,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _lookahead: 'lookahead'
        },
        Grammar: {
            name: Grammar,
            properties: {
                imports: {
                    name: 'imports',
                    defaultValue: []
                },
                interfaces: {
                    name: 'interfaces',
                    defaultValue: []
                },
                isDeclared: {
                    name: 'isDeclared',
                    defaultValue: false
                },
                name: {
                    name: 'name'
                },
                rules: {
                    name: 'rules',
                    defaultValue: []
                },
                types: {
                    name: 'types',
                    defaultValue: []
                }
            },
            superTypes: [],
            // Property name constants
            _imports: 'imports',
            _interfaces: 'interfaces',
            _isDeclared: 'isDeclared',
            _name: 'name',
            _rules: 'rules',
            _types: 'types'
        },
        GrammarImport: {
            name: GrammarImport,
            properties: {
                path: {
                    name: 'path'
                }
            },
            superTypes: [],
            // Property name constants
            _path: 'path'
        },
        Group: {
            name: Group,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                elements: {
                    name: 'elements',
                    defaultValue: []
                },
                guardCondition: {
                    name: 'guardCondition'
                },
                lookahead: {
                    name: 'lookahead'
                },
                predicate: {
                    name: 'predicate'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _elements: 'elements',
            _guardCondition: 'guardCondition',
            _lookahead: 'lookahead',
            _predicate: 'predicate'
        },
        InferredType: {
            name: InferredType,
            properties: {
                name: {
                    name: 'name'
                }
            },
            superTypes: ['AbstractType'],
            // Property name constants
            _name: 'name'
        },
        InfixRule: {
            name: InfixRule,
            properties: {
                call: {
                    name: 'call'
                },
                name: {
                    name: 'name'
                },
                operators: {
                    name: 'operators'
                },
                parameters: {
                    name: 'parameters',
                    defaultValue: []
                }
            },
            superTypes: ['AbstractRule', 'AbstractType'],
            // Property name constants
            _call: 'call',
            _name: 'name',
            _operators: 'operators',
            _parameters: 'parameters'
        },
        InfixRuleOperatorList: {
            name: InfixRuleOperatorList,
            properties: {
                associativity: {
                    name: 'associativity'
                },
                operators: {
                    name: 'operators',
                    defaultValue: []
                }
            },
            superTypes: [],
            // Property name constants
            _associativity: 'associativity',
            _operators: 'operators'
        },
        InfixRuleOperators: {
            name: InfixRuleOperators,
            properties: {
                precedences: {
                    name: 'precedences',
                    defaultValue: []
                }
            },
            superTypes: [],
            // Property name constants
            _precedences: 'precedences'
        },
        Interface: {
            name: Interface,
            properties: {
                attributes: {
                    name: 'attributes',
                    defaultValue: []
                },
                name: {
                    name: 'name'
                },
                superTypes: {
                    name: 'superTypes',
                    defaultValue: [],
                    referenceType: 'AbstractType'
                }
            },
            superTypes: ['AbstractType'],
            // Property name constants
            _attributes: 'attributes',
            _name: 'name',
            _superTypes: 'superTypes'
        },
        Keyword: {
            name: Keyword,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                },
                predicate: {
                    name: 'predicate'
                },
                value: {
                    name: 'value'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _lookahead: 'lookahead',
            _predicate: 'predicate',
            _value: 'value'
        },
        NamedArgument: {
            name: NamedArgument,
            properties: {
                calledByName: {
                    name: 'calledByName',
                    defaultValue: false
                },
                parameter: {
                    name: 'parameter',
                    referenceType: 'Parameter'
                },
                value: {
                    name: 'value'
                }
            },
            superTypes: [],
            // Property name constants
            _calledByName: 'calledByName',
            _parameter: 'parameter',
            _value: 'value'
        },
        NegatedToken: {
            name: NegatedToken,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                },
                terminal: {
                    name: 'terminal'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _lookahead: 'lookahead',
            _terminal: 'terminal'
        },
        Negation: {
            name: Negation,
            properties: {
                value: {
                    name: 'value'
                }
            },
            superTypes: ['Condition'],
            // Property name constants
            _value: 'value'
        },
        NumberLiteral: {
            name: NumberLiteral,
            properties: {
                value: {
                    name: 'value'
                }
            },
            superTypes: ['ValueLiteral'],
            // Property name constants
            _value: 'value'
        },
        Parameter: {
            name: Parameter,
            properties: {
                name: {
                    name: 'name'
                }
            },
            superTypes: [],
            // Property name constants
            _name: 'name'
        },
        ParameterReference: {
            name: ParameterReference,
            properties: {
                parameter: {
                    name: 'parameter',
                    referenceType: 'Parameter'
                }
            },
            superTypes: ['Condition'],
            // Property name constants
            _parameter: 'parameter'
        },
        ParserRule: {
            name: ParserRule,
            properties: {
                dataType: {
                    name: 'dataType'
                },
                definition: {
                    name: 'definition'
                },
                entry: {
                    name: 'entry',
                    defaultValue: false
                },
                fragment: {
                    name: 'fragment',
                    defaultValue: false
                },
                inferredType: {
                    name: 'inferredType'
                },
                name: {
                    name: 'name'
                },
                parameters: {
                    name: 'parameters',
                    defaultValue: []
                },
                returnType: {
                    name: 'returnType',
                    referenceType: 'AbstractType'
                }
            },
            superTypes: ['AbstractRule', 'AbstractType'],
            // Property name constants
            _dataType: 'dataType',
            _definition: 'definition',
            _entry: 'entry',
            _fragment: 'fragment',
            _inferredType: 'inferredType',
            _name: 'name',
            _parameters: 'parameters',
            _returnType: 'returnType'
        },
        ReferenceType: {
            name: ReferenceType,
            properties: {
                referenceType: {
                    name: 'referenceType'
                }
            },
            superTypes: ['TypeDefinition'],
            // Property name constants
            _referenceType: 'referenceType'
        },
        RegexToken: {
            name: RegexToken,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                },
                regex: {
                    name: 'regex'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _lookahead: 'lookahead',
            _regex: 'regex'
        },
        ReturnType: {
            name: ReturnType,
            properties: {
                name: {
                    name: 'name'
                }
            },
            superTypes: [],
            // Property name constants
            _name: 'name'
        },
        RuleCall: {
            name: RuleCall,
            properties: {
                arguments: {
                    name: 'arguments',
                    defaultValue: []
                },
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                },
                predicate: {
                    name: 'predicate'
                },
                rule: {
                    name: 'rule',
                    referenceType: 'AbstractRule'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _arguments: 'arguments',
            _cardinality: 'cardinality',
            _lookahead: 'lookahead',
            _predicate: 'predicate',
            _rule: 'rule'
        },
        SimpleType: {
            name: SimpleType,
            properties: {
                primitiveType: {
                    name: 'primitiveType'
                },
                stringType: {
                    name: 'stringType'
                },
                typeRef: {
                    name: 'typeRef',
                    referenceType: 'AbstractType'
                }
            },
            superTypes: ['TypeDefinition'],
            // Property name constants
            _primitiveType: 'primitiveType',
            _stringType: 'stringType',
            _typeRef: 'typeRef'
        },
        StringLiteral: {
            name: StringLiteral,
            properties: {
                value: {
                    name: 'value'
                }
            },
            superTypes: ['ValueLiteral'],
            // Property name constants
            _value: 'value'
        },
        TerminalAlternatives: {
            name: TerminalAlternatives,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                elements: {
                    name: 'elements',
                    defaultValue: []
                },
                lookahead: {
                    name: 'lookahead'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _elements: 'elements',
            _lookahead: 'lookahead'
        },
        TerminalGroup: {
            name: TerminalGroup,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                elements: {
                    name: 'elements',
                    defaultValue: []
                },
                lookahead: {
                    name: 'lookahead'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _elements: 'elements',
            _lookahead: 'lookahead'
        },
        TerminalRule: {
            name: TerminalRule,
            properties: {
                definition: {
                    name: 'definition'
                },
                fragment: {
                    name: 'fragment',
                    defaultValue: false
                },
                hidden: {
                    name: 'hidden',
                    defaultValue: false
                },
                name: {
                    name: 'name'
                },
                type: {
                    name: 'type'
                }
            },
            superTypes: ['AbstractRule'],
            // Property name constants
            _definition: 'definition',
            _fragment: 'fragment',
            _hidden: 'hidden',
            _name: 'name',
            _type: 'type'
        },
        TerminalRuleCall: {
            name: TerminalRuleCall,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                },
                rule: {
                    name: 'rule',
                    referenceType: 'TerminalRule'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _lookahead: 'lookahead',
            _rule: 'rule'
        },
        Type: {
            name: Type,
            properties: {
                name: {
                    name: 'name'
                },
                type: {
                    name: 'type'
                }
            },
            superTypes: ['AbstractType'],
            // Property name constants
            _name: 'name',
            _type: 'type'
        },
        TypeAttribute: {
            name: TypeAttribute,
            properties: {
                defaultValue: {
                    name: 'defaultValue'
                },
                isOptional: {
                    name: 'isOptional',
                    defaultValue: false
                },
                name: {
                    name: 'name'
                },
                type: {
                    name: 'type'
                }
            },
            superTypes: [],
            // Property name constants
            _defaultValue: 'defaultValue',
            _isOptional: 'isOptional',
            _name: 'name',
            _type: 'type'
        },
        UnionType: {
            name: UnionType,
            properties: {
                types: {
                    name: 'types',
                    defaultValue: []
                }
            },
            superTypes: ['TypeDefinition'],
            // Property name constants
            _types: 'types'
        },
        UnorderedGroup: {
            name: UnorderedGroup,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                elements: {
                    name: 'elements',
                    defaultValue: []
                },
                lookahead: {
                    name: 'lookahead'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _elements: 'elements',
            _lookahead: 'lookahead'
        },
        UntilToken: {
            name: UntilToken,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                },
                terminal: {
                    name: 'terminal'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _lookahead: 'lookahead',
            _terminal: 'terminal'
        },
        Wildcard: {
            name: Wildcard,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                }
            },
            superTypes: ['AbstractElement'],
            // Property name constants
            _cardinality: 'cardinality',
            _lookahead: 'lookahead'
        }
    } as const satisfies langium.AstMetaData
}

export const reflection = new LangiumGrammarAstReflection();

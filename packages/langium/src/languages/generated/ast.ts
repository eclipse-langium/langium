/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from '../../syntax-tree.js';

export const LangiumGrammarTerminals = {
    ID: /\^?[_a-zA-Z][\w_]*/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    NUMBER: /NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity)/,
    RegexLiteral: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\/[a-z]*/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type LangiumGrammarTerminalNames = keyof typeof LangiumGrammarTerminals;

export type LangiumGrammarKeywordNames =
    | "!"
    | "&"
    | "("
    | ")"
    | "*"
    | "+"
    | "+="
    | ","
    | "->"
    | "."
    | ".."
    | ":"
    | ";"
    | "<"
    | "="
    | "=>"
    | ">"
    | "?"
    | "?!"
    | "?<!"
    | "?<="
    | "?="
    | "@"
    | "Date"
    | "EOF"
    | "["
    | "]"
    | "assoc"
    | "bigint"
    | "boolean"
    | "current"
    | "entry"
    | "extends"
    | "false"
    | "fragment"
    | "grammar"
    | "hidden"
    | "import"
    | "infer"
    | "infers"
    | "infix"
    | "interface"
    | "left"
    | "number"
    | "on"
    | "returns"
    | "right"
    | "string"
    | "terminal"
    | "true"
    | "type"
    | "with"
    | "{"
    | "|"
    | "}";

export type LangiumGrammarTokenNames = LangiumGrammarTerminalNames | LangiumGrammarKeywordNames;

export type AbstractRule = InfixRule | ParserRule | TerminalRule;

/** @deprecated Use `$AbstractRule.$type` instead. */
export const AbstractRule = 'AbstractRule';
export const $AbstractRule = {
    $type: 'AbstractRule'
} as const;

export function isAbstractRule(item: unknown): item is AbstractRule {
    return reflection.isInstance(item, $AbstractRule.$type);
}

export type AbstractType = InferredType | InfixRule | Interface | ParserRule | Type;

/** @deprecated Use `$AbstractType.$type` instead. */
export const AbstractType = 'AbstractType';
export const $AbstractType = {
    $type: 'AbstractType'
} as const;

export function isAbstractType(item: unknown): item is AbstractType {
    return reflection.isInstance(item, $AbstractType.$type);
}

export type Associativity = 'left' | 'right';

export function isAssociativity(item: unknown): item is Associativity {
    return item === 'left' || item === 'right';
}

export type Condition = BooleanLiteral | Conjunction | Disjunction | Negation | ParameterReference;

/** @deprecated Use `$Condition.$type` instead. */
export const Condition = 'Condition';
export const $Condition = {
    $type: 'Condition'
} as const;

export function isCondition(item: unknown): item is Condition {
    return reflection.isInstance(item, $Condition.$type);
}

export type FeatureName = 'assoc' | 'current' | 'entry' | 'extends' | 'false' | 'fragment' | 'grammar' | 'hidden' | 'import' | 'infer' | 'infers' | 'infix' | 'interface' | 'left' | 'on' | 'returns' | 'right' | 'terminal' | 'true' | 'type' | 'with' | PrimitiveType | string;

export function isFeatureName(item: unknown): item is FeatureName {
    return isPrimitiveType(item) || item === 'infix' || item === 'on' || item === 'right' || item === 'left' || item === 'assoc' || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\^?[_a-zA-Z][\w_]*/.test(item)));
}

export type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';

export function isPrimitiveType(item: unknown): item is PrimitiveType {
    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';
}

export type TypeDefinition = ArrayType | ReferenceType | SimpleType | UnionType;

/** @deprecated Use `$TypeDefinition.$type` instead. */
export const TypeDefinition = 'TypeDefinition';
export const $TypeDefinition = {
    $type: 'TypeDefinition'
} as const;

export function isTypeDefinition(item: unknown): item is TypeDefinition {
    return reflection.isInstance(item, $TypeDefinition.$type);
}

export type ValueLiteral = ArrayLiteral | BooleanLiteral | NumberLiteral | StringLiteral;

/** @deprecated Use `$ValueLiteral.$type` instead. */
export const ValueLiteral = 'ValueLiteral';
export const $ValueLiteral = {
    $type: 'ValueLiteral'
} as const;

export function isValueLiteral(item: unknown): item is ValueLiteral {
    return reflection.isInstance(item, $ValueLiteral.$type);
}

export interface AbstractElement extends langium.AstNode {
    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'EndOfFile' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';
    cardinality?: '*' | '+' | '?';
    lookahead?: '?!' | '?<!' | '?<=' | '?=';
}

/** @deprecated Use `$AbstractElement.$type` instead. */
export const AbstractElement = 'AbstractElement';
export const $AbstractElement = {
    $type: 'AbstractElement',
    cardinality: 'cardinality',
    lookahead: 'lookahead'
} as const;

export function isAbstractElement(item: unknown): item is AbstractElement {
    return reflection.isInstance(item, $AbstractElement.$type);
}

export interface ArrayLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'ArrayLiteral';
    elements: Array<ValueLiteral>;
}

/** @deprecated Use `$ArrayLiteral.$type` instead. */
export const ArrayLiteral = 'ArrayLiteral';
export const $ArrayLiteral = {
    $type: 'ArrayLiteral',
    elements: 'elements'
} as const;

export function isArrayLiteral(item: unknown): item is ArrayLiteral {
    return reflection.isInstance(item, $ArrayLiteral.$type);
}

export interface ArrayType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ArrayType';
    elementType: TypeDefinition;
}

/** @deprecated Use `$ArrayType.$type` instead. */
export const ArrayType = 'ArrayType';
export const $ArrayType = {
    $type: 'ArrayType',
    elementType: 'elementType'
} as const;

export function isArrayType(item: unknown): item is ArrayType {
    return reflection.isInstance(item, $ArrayType.$type);
}

export interface BooleanLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | Conjunction | Disjunction | Group | NamedArgument | Negation | TypeAttribute;
    readonly $type: 'BooleanLiteral';
    true: boolean;
}

/** @deprecated Use `$BooleanLiteral.$type` instead. */
export const BooleanLiteral = 'BooleanLiteral';
export const $BooleanLiteral = {
    $type: 'BooleanLiteral',
    true: 'true'
} as const;

export function isBooleanLiteral(item: unknown): item is BooleanLiteral {
    return reflection.isInstance(item, $BooleanLiteral.$type);
}

export interface Conjunction extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Conjunction';
    left: Condition;
    right: Condition;
}

/** @deprecated Use `$Conjunction.$type` instead. */
export const Conjunction = 'Conjunction';
export const $Conjunction = {
    $type: 'Conjunction',
    left: 'left',
    right: 'right'
} as const;

export function isConjunction(item: unknown): item is Conjunction {
    return reflection.isInstance(item, $Conjunction.$type);
}

export interface Disjunction extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Disjunction';
    left: Condition;
    right: Condition;
}

/** @deprecated Use `$Disjunction.$type` instead. */
export const Disjunction = 'Disjunction';
export const $Disjunction = {
    $type: 'Disjunction',
    left: 'left',
    right: 'right'
} as const;

export function isDisjunction(item: unknown): item is Disjunction {
    return reflection.isInstance(item, $Disjunction.$type);
}

export interface Grammar extends langium.AstNode {
    readonly $type: 'Grammar';
    imports: Array<GrammarImport>;
    interfaces: Array<Interface>;
    isDeclared: boolean;
    name?: string;
    rules: Array<AbstractRule>;
    types: Array<Type>;
}

/** @deprecated Use `$Grammar.$type` instead. */
export const Grammar = 'Grammar';
export const $Grammar = {
    $type: 'Grammar',
    imports: 'imports',
    interfaces: 'interfaces',
    isDeclared: 'isDeclared',
    name: 'name',
    rules: 'rules',
    types: 'types'
} as const;

export function isGrammar(item: unknown): item is Grammar {
    return reflection.isInstance(item, $Grammar.$type);
}

export interface GrammarImport extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'GrammarImport';
    path: string;
}

/** @deprecated Use `$GrammarImport.$type` instead. */
export const GrammarImport = 'GrammarImport';
export const $GrammarImport = {
    $type: 'GrammarImport',
    path: 'path'
} as const;

export function isGrammarImport(item: unknown): item is GrammarImport {
    return reflection.isInstance(item, $GrammarImport.$type);
}

export interface InferredType extends langium.AstNode {
    readonly $container: Action | ParserRule;
    readonly $type: 'InferredType';
    name: string;
}

/** @deprecated Use `$InferredType.$type` instead. */
export const InferredType = 'InferredType';
export const $InferredType = {
    $type: 'InferredType',
    name: 'name'
} as const;

export function isInferredType(item: unknown): item is InferredType {
    return reflection.isInstance(item, $InferredType.$type);
}

export interface InfixRule extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'InfixRule';
    call: RuleCall;
    name: string;
    operators: InfixRuleOperators;
    parameters: Array<Parameter>;
}

/** @deprecated Use `$InfixRule.$type` instead. */
export const InfixRule = 'InfixRule';
export const $InfixRule = {
    $type: 'InfixRule',
    call: 'call',
    name: 'name',
    operators: 'operators',
    parameters: 'parameters'
} as const;

export function isInfixRule(item: unknown): item is InfixRule {
    return reflection.isInstance(item, $InfixRule.$type);
}

export interface InfixRuleOperatorList extends langium.AstNode {
    readonly $container: InfixRuleOperators;
    readonly $type: 'InfixRuleOperatorList';
    associativity?: Associativity;
    operators: Array<Keyword>;
}

/** @deprecated Use `$InfixRuleOperatorList.$type` instead. */
export const InfixRuleOperatorList = 'InfixRuleOperatorList';
export const $InfixRuleOperatorList = {
    $type: 'InfixRuleOperatorList',
    associativity: 'associativity',
    operators: 'operators'
} as const;

export function isInfixRuleOperatorList(item: unknown): item is InfixRuleOperatorList {
    return reflection.isInstance(item, $InfixRuleOperatorList.$type);
}

export interface InfixRuleOperators extends langium.AstNode {
    readonly $container: InfixRule;
    readonly $type: 'InfixRuleOperators';
    precedences: Array<InfixRuleOperatorList>;
}

/** @deprecated Use `$InfixRuleOperators.$type` instead. */
export const InfixRuleOperators = 'InfixRuleOperators';
export const $InfixRuleOperators = {
    $type: 'InfixRuleOperators',
    precedences: 'precedences'
} as const;

export function isInfixRuleOperators(item: unknown): item is InfixRuleOperators {
    return reflection.isInstance(item, $InfixRuleOperators.$type);
}

export interface Interface extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'Interface';
    attributes: Array<TypeAttribute>;
    name: string;
    superTypes: Array<langium.Reference<AbstractType>>;
}

/** @deprecated Use `$Interface.$type` instead. */
export const Interface = 'Interface';
export const $Interface = {
    $type: 'Interface',
    attributes: 'attributes',
    name: 'name',
    superTypes: 'superTypes'
} as const;

export function isInterface(item: unknown): item is Interface {
    return reflection.isInstance(item, $Interface.$type);
}

export interface NamedArgument extends langium.AstNode {
    readonly $container: RuleCall;
    readonly $type: 'NamedArgument';
    calledByName: boolean;
    parameter?: langium.Reference<Parameter>;
    value: Condition;
}

/** @deprecated Use `$NamedArgument.$type` instead. */
export const NamedArgument = 'NamedArgument';
export const $NamedArgument = {
    $type: 'NamedArgument',
    calledByName: 'calledByName',
    parameter: 'parameter',
    value: 'value'
} as const;

export function isNamedArgument(item: unknown): item is NamedArgument {
    return reflection.isInstance(item, $NamedArgument.$type);
}

export interface Negation extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Negation';
    value: Condition;
}

/** @deprecated Use `$Negation.$type` instead. */
export const Negation = 'Negation';
export const $Negation = {
    $type: 'Negation',
    value: 'value'
} as const;

export function isNegation(item: unknown): item is Negation {
    return reflection.isInstance(item, $Negation.$type);
}

export interface NumberLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'NumberLiteral';
    value: number;
}

/** @deprecated Use `$NumberLiteral.$type` instead. */
export const NumberLiteral = 'NumberLiteral';
export const $NumberLiteral = {
    $type: 'NumberLiteral',
    value: 'value'
} as const;

export function isNumberLiteral(item: unknown): item is NumberLiteral {
    return reflection.isInstance(item, $NumberLiteral.$type);
}

export interface Parameter extends langium.AstNode {
    readonly $container: InfixRule | ParserRule;
    readonly $type: 'Parameter';
    name: string;
}

/** @deprecated Use `$Parameter.$type` instead. */
export const Parameter = 'Parameter';
export const $Parameter = {
    $type: 'Parameter',
    name: 'name'
} as const;

export function isParameter(item: unknown): item is Parameter {
    return reflection.isInstance(item, $Parameter.$type);
}

export interface ParameterReference extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'ParameterReference';
    parameter: langium.Reference<Parameter>;
}

/** @deprecated Use `$ParameterReference.$type` instead. */
export const ParameterReference = 'ParameterReference';
export const $ParameterReference = {
    $type: 'ParameterReference',
    parameter: 'parameter'
} as const;

export function isParameterReference(item: unknown): item is ParameterReference {
    return reflection.isInstance(item, $ParameterReference.$type);
}

export interface ParserRule extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'ParserRule';
    dataType?: PrimitiveType;
    definition: AbstractElement;
    entry: boolean;
    fragment: boolean;
    inferredType?: InferredType;
    name: string;
    parameters: Array<Parameter>;
    returnType?: langium.Reference<AbstractType>;
}

/** @deprecated Use `$ParserRule.$type` instead. */
export const ParserRule = 'ParserRule';
export const $ParserRule = {
    $type: 'ParserRule',
    dataType: 'dataType',
    definition: 'definition',
    entry: 'entry',
    fragment: 'fragment',
    inferredType: 'inferredType',
    name: 'name',
    parameters: 'parameters',
    returnType: 'returnType'
} as const;

export function isParserRule(item: unknown): item is ParserRule {
    return reflection.isInstance(item, $ParserRule.$type);
}

export interface ReferenceType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ReferenceType';
    referenceType: TypeDefinition;
}

/** @deprecated Use `$ReferenceType.$type` instead. */
export const ReferenceType = 'ReferenceType';
export const $ReferenceType = {
    $type: 'ReferenceType',
    referenceType: 'referenceType'
} as const;

export function isReferenceType(item: unknown): item is ReferenceType {
    return reflection.isInstance(item, $ReferenceType.$type);
}

export interface ReturnType extends langium.AstNode {
    readonly $container: TerminalRule;
    readonly $type: 'ReturnType';
    name: PrimitiveType | string;
}

/** @deprecated Use `$ReturnType.$type` instead. */
export const ReturnType = 'ReturnType';
export const $ReturnType = {
    $type: 'ReturnType',
    name: 'name'
} as const;

export function isReturnType(item: unknown): item is ReturnType {
    return reflection.isInstance(item, $ReturnType.$type);
}

export interface SimpleType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'SimpleType';
    primitiveType?: PrimitiveType;
    stringType?: string;
    typeRef?: langium.Reference<AbstractType>;
}

/** @deprecated Use `$SimpleType.$type` instead. */
export const SimpleType = 'SimpleType';
export const $SimpleType = {
    $type: 'SimpleType',
    primitiveType: 'primitiveType',
    stringType: 'stringType',
    typeRef: 'typeRef'
} as const;

export function isSimpleType(item: unknown): item is SimpleType {
    return reflection.isInstance(item, $SimpleType.$type);
}

export interface StringLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'StringLiteral';
    value: string;
}

/** @deprecated Use `$StringLiteral.$type` instead. */
export const StringLiteral = 'StringLiteral';
export const $StringLiteral = {
    $type: 'StringLiteral',
    value: 'value'
} as const;

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, $StringLiteral.$type);
}

export interface TerminalRule extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'TerminalRule';
    definition: AbstractElement;
    fragment: boolean;
    hidden: boolean;
    name: string;
    type?: ReturnType;
}

/** @deprecated Use `$TerminalRule.$type` instead. */
export const TerminalRule = 'TerminalRule';
export const $TerminalRule = {
    $type: 'TerminalRule',
    definition: 'definition',
    fragment: 'fragment',
    hidden: 'hidden',
    name: 'name',
    type: 'type'
} as const;

export function isTerminalRule(item: unknown): item is TerminalRule {
    return reflection.isInstance(item, $TerminalRule.$type);
}

export interface Type extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'Type';
    name: string;
    type: TypeDefinition;
}

/** @deprecated Use `$Type.$type` instead. */
export const Type = 'Type';
export const $Type = {
    $type: 'Type',
    name: 'name',
    type: 'type'
} as const;

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, $Type.$type);
}

export interface TypeAttribute extends langium.AstNode {
    readonly $container: Interface;
    readonly $type: 'TypeAttribute';
    defaultValue?: ValueLiteral;
    isOptional: boolean;
    name: FeatureName;
    type: TypeDefinition;
}

/** @deprecated Use `$TypeAttribute.$type` instead. */
export const TypeAttribute = 'TypeAttribute';
export const $TypeAttribute = {
    $type: 'TypeAttribute',
    defaultValue: 'defaultValue',
    isOptional: 'isOptional',
    name: 'name',
    type: 'type'
} as const;

export function isTypeAttribute(item: unknown): item is TypeAttribute {
    return reflection.isInstance(item, $TypeAttribute.$type);
}

export interface UnionType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'UnionType';
    types: Array<TypeDefinition>;
}

/** @deprecated Use `$UnionType.$type` instead. */
export const UnionType = 'UnionType';
export const $UnionType = {
    $type: 'UnionType',
    types: 'types'
} as const;

export function isUnionType(item: unknown): item is UnionType {
    return reflection.isInstance(item, $UnionType.$type);
}

export interface Action extends AbstractElement {
    readonly $type: 'Action';
    feature?: FeatureName;
    inferredType?: InferredType;
    operator?: '+=' | '=';
    type?: langium.Reference<AbstractType>;
}

/** @deprecated Use `$Action.$type` instead. */
export const Action = 'Action';
export const $Action = {
    $type: 'Action',
    cardinality: 'cardinality',
    feature: 'feature',
    inferredType: 'inferredType',
    lookahead: 'lookahead',
    operator: 'operator',
    type: 'type'
} as const;

export function isAction(item: unknown): item is Action {
    return reflection.isInstance(item, $Action.$type);
}

export interface Alternatives extends AbstractElement {
    readonly $type: 'Alternatives';
    elements: Array<AbstractElement>;
}

/** @deprecated Use `$Alternatives.$type` instead. */
export const Alternatives = 'Alternatives';
export const $Alternatives = {
    $type: 'Alternatives',
    cardinality: 'cardinality',
    elements: 'elements',
    lookahead: 'lookahead'
} as const;

export function isAlternatives(item: unknown): item is Alternatives {
    return reflection.isInstance(item, $Alternatives.$type);
}

export interface Assignment extends AbstractElement {
    readonly $type: 'Assignment';
    feature: FeatureName;
    operator: '+=' | '=' | '?=';
    predicate?: '->' | '=>';
    terminal: AbstractElement;
}

/** @deprecated Use `$Assignment.$type` instead. */
export const Assignment = 'Assignment';
export const $Assignment = {
    $type: 'Assignment',
    cardinality: 'cardinality',
    feature: 'feature',
    lookahead: 'lookahead',
    operator: 'operator',
    predicate: 'predicate',
    terminal: 'terminal'
} as const;

export function isAssignment(item: unknown): item is Assignment {
    return reflection.isInstance(item, $Assignment.$type);
}

export interface CharacterRange extends AbstractElement {
    readonly $type: 'CharacterRange';
    left: Keyword;
    right?: Keyword;
}

/** @deprecated Use `$CharacterRange.$type` instead. */
export const CharacterRange = 'CharacterRange';
export const $CharacterRange = {
    $type: 'CharacterRange',
    cardinality: 'cardinality',
    left: 'left',
    lookahead: 'lookahead',
    right: 'right'
} as const;

export function isCharacterRange(item: unknown): item is CharacterRange {
    return reflection.isInstance(item, $CharacterRange.$type);
}

export interface CrossReference extends AbstractElement {
    readonly $type: 'CrossReference';
    deprecatedSyntax: boolean;
    terminal?: AbstractElement;
    type: langium.Reference<AbstractType>;
}

/** @deprecated Use `$CrossReference.$type` instead. */
export const CrossReference = 'CrossReference';
export const $CrossReference = {
    $type: 'CrossReference',
    cardinality: 'cardinality',
    deprecatedSyntax: 'deprecatedSyntax',
    lookahead: 'lookahead',
    terminal: 'terminal',
    type: 'type'
} as const;

export function isCrossReference(item: unknown): item is CrossReference {
    return reflection.isInstance(item, $CrossReference.$type);
}

export interface EndOfFile extends AbstractElement {
    readonly $type: 'EndOfFile';
}

/** @deprecated Use `$EndOfFile.$type` instead. */
export const EndOfFile = 'EndOfFile';
export const $EndOfFile = {
    $type: 'EndOfFile',
    cardinality: 'cardinality',
    lookahead: 'lookahead'
} as const;

export function isEndOfFile(item: unknown): item is EndOfFile {
    return reflection.isInstance(item, $EndOfFile.$type);
}

export interface Group extends AbstractElement {
    readonly $type: 'Group';
    elements: Array<AbstractElement>;
    guardCondition?: Condition;
    predicate?: '->' | '=>';
}

/** @deprecated Use `$Group.$type` instead. */
export const Group = 'Group';
export const $Group = {
    $type: 'Group',
    cardinality: 'cardinality',
    elements: 'elements',
    guardCondition: 'guardCondition',
    lookahead: 'lookahead',
    predicate: 'predicate'
} as const;

export function isGroup(item: unknown): item is Group {
    return reflection.isInstance(item, $Group.$type);
}

export interface Keyword extends AbstractElement {
    readonly $container: CharacterRange | InfixRuleOperatorList;
    readonly $type: 'Keyword';
    predicate?: '->' | '=>';
    value: string;
}

/** @deprecated Use `$Keyword.$type` instead. */
export const Keyword = 'Keyword';
export const $Keyword = {
    $type: 'Keyword',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    predicate: 'predicate',
    value: 'value'
} as const;

export function isKeyword(item: unknown): item is Keyword {
    return reflection.isInstance(item, $Keyword.$type);
}

export interface NegatedToken extends AbstractElement {
    readonly $type: 'NegatedToken';
    terminal: AbstractElement;
}

/** @deprecated Use `$NegatedToken.$type` instead. */
export const NegatedToken = 'NegatedToken';
export const $NegatedToken = {
    $type: 'NegatedToken',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    terminal: 'terminal'
} as const;

export function isNegatedToken(item: unknown): item is NegatedToken {
    return reflection.isInstance(item, $NegatedToken.$type);
}

export interface RegexToken extends AbstractElement {
    readonly $type: 'RegexToken';
    regex: string;
}

/** @deprecated Use `$RegexToken.$type` instead. */
export const RegexToken = 'RegexToken';
export const $RegexToken = {
    $type: 'RegexToken',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    regex: 'regex'
} as const;

export function isRegexToken(item: unknown): item is RegexToken {
    return reflection.isInstance(item, $RegexToken.$type);
}

export interface RuleCall extends AbstractElement {
    readonly $container: InfixRule;
    readonly $type: 'RuleCall';
    arguments: Array<NamedArgument>;
    predicate?: '->' | '=>';
    rule: langium.Reference<AbstractRule>;
}

/** @deprecated Use `$RuleCall.$type` instead. */
export const RuleCall = 'RuleCall';
export const $RuleCall = {
    $type: 'RuleCall',
    arguments: 'arguments',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    predicate: 'predicate',
    rule: 'rule'
} as const;

export function isRuleCall(item: unknown): item is RuleCall {
    return reflection.isInstance(item, $RuleCall.$type);
}

export interface TerminalAlternatives extends AbstractElement {
    readonly $type: 'TerminalAlternatives';
    elements: Array<AbstractElement>;
}

/** @deprecated Use `$TerminalAlternatives.$type` instead. */
export const TerminalAlternatives = 'TerminalAlternatives';
export const $TerminalAlternatives = {
    $type: 'TerminalAlternatives',
    cardinality: 'cardinality',
    elements: 'elements',
    lookahead: 'lookahead'
} as const;

export function isTerminalAlternatives(item: unknown): item is TerminalAlternatives {
    return reflection.isInstance(item, $TerminalAlternatives.$type);
}

export interface TerminalGroup extends AbstractElement {
    readonly $type: 'TerminalGroup';
    elements: Array<AbstractElement>;
}

/** @deprecated Use `$TerminalGroup.$type` instead. */
export const TerminalGroup = 'TerminalGroup';
export const $TerminalGroup = {
    $type: 'TerminalGroup',
    cardinality: 'cardinality',
    elements: 'elements',
    lookahead: 'lookahead'
} as const;

export function isTerminalGroup(item: unknown): item is TerminalGroup {
    return reflection.isInstance(item, $TerminalGroup.$type);
}

export interface TerminalRuleCall extends AbstractElement {
    readonly $type: 'TerminalRuleCall';
    rule: langium.Reference<TerminalRule>;
}

/** @deprecated Use `$TerminalRuleCall.$type` instead. */
export const TerminalRuleCall = 'TerminalRuleCall';
export const $TerminalRuleCall = {
    $type: 'TerminalRuleCall',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    rule: 'rule'
} as const;

export function isTerminalRuleCall(item: unknown): item is TerminalRuleCall {
    return reflection.isInstance(item, $TerminalRuleCall.$type);
}

export interface UnorderedGroup extends AbstractElement {
    readonly $type: 'UnorderedGroup';
    elements: Array<AbstractElement>;
}

/** @deprecated Use `$UnorderedGroup.$type` instead. */
export const UnorderedGroup = 'UnorderedGroup';
export const $UnorderedGroup = {
    $type: 'UnorderedGroup',
    cardinality: 'cardinality',
    elements: 'elements',
    lookahead: 'lookahead'
} as const;

export function isUnorderedGroup(item: unknown): item is UnorderedGroup {
    return reflection.isInstance(item, $UnorderedGroup.$type);
}

export interface UntilToken extends AbstractElement {
    readonly $type: 'UntilToken';
    terminal: AbstractElement;
}

/** @deprecated Use `$UntilToken.$type` instead. */
export const UntilToken = 'UntilToken';
export const $UntilToken = {
    $type: 'UntilToken',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    terminal: 'terminal'
} as const;

export function isUntilToken(item: unknown): item is UntilToken {
    return reflection.isInstance(item, $UntilToken.$type);
}

export interface Wildcard extends AbstractElement {
    readonly $type: 'Wildcard';
}

/** @deprecated Use `$Wildcard.$type` instead. */
export const Wildcard = 'Wildcard';
export const $Wildcard = {
    $type: 'Wildcard',
    cardinality: 'cardinality',
    lookahead: 'lookahead'
} as const;

export function isWildcard(item: unknown): item is Wildcard {
    return reflection.isInstance(item, $Wildcard.$type);
}

export type LangiumGrammarAstType = {
    AbstractElement: AbstractElement
    AbstractRule: AbstractRule
    AbstractType: AbstractType
    Action: Action
    Alternatives: Alternatives
    ArrayLiteral: ArrayLiteral
    ArrayType: ArrayType
    Assignment: Assignment
    BooleanLiteral: BooleanLiteral
    CharacterRange: CharacterRange
    Condition: Condition
    Conjunction: Conjunction
    CrossReference: CrossReference
    Disjunction: Disjunction
    EndOfFile: EndOfFile
    Grammar: Grammar
    GrammarImport: GrammarImport
    Group: Group
    InferredType: InferredType
    InfixRule: InfixRule
    InfixRuleOperatorList: InfixRuleOperatorList
    InfixRuleOperators: InfixRuleOperators
    Interface: Interface
    Keyword: Keyword
    NamedArgument: NamedArgument
    NegatedToken: NegatedToken
    Negation: Negation
    NumberLiteral: NumberLiteral
    Parameter: Parameter
    ParameterReference: ParameterReference
    ParserRule: ParserRule
    ReferenceType: ReferenceType
    RegexToken: RegexToken
    ReturnType: ReturnType
    RuleCall: RuleCall
    SimpleType: SimpleType
    StringLiteral: StringLiteral
    TerminalAlternatives: TerminalAlternatives
    TerminalGroup: TerminalGroup
    TerminalRule: TerminalRule
    TerminalRuleCall: TerminalRuleCall
    Type: Type
    TypeAttribute: TypeAttribute
    TypeDefinition: TypeDefinition
    UnionType: UnionType
    UnorderedGroup: UnorderedGroup
    UntilToken: UntilToken
    ValueLiteral: ValueLiteral
    Wildcard: Wildcard
}

export class LangiumGrammarAstReflection extends langium.AbstractAstReflection {
    override readonly types = {
        AbstractElement: {
            name: $AbstractElement.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                }
            },
            superTypes: []
        },
        Action: {
            name: $Action.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                feature: {
                    name: 'feature'
                },
                inferredType: {
                    name: 'inferredType'
                },
                lookahead: {
                    name: 'lookahead'
                },
                operator: {
                    name: 'operator'
                },
                type: {
                    name: 'type',
                    referenceType: 'AbstractType'
                }
            },
            superTypes: ['AbstractElement']
        },
        Alternatives: {
            name: $Alternatives.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                elements: {
                    name: 'elements',
                    defaultValue: []
                },
                lookahead: {
                    name: 'lookahead'
                }
            },
            superTypes: ['AbstractElement']
        },
        ArrayLiteral: {
            name: $ArrayLiteral.$type,
            properties: {
                elements: {
                    name: 'elements',
                    defaultValue: []
                }
            },
            superTypes: ['ValueLiteral']
        },
        ArrayType: {
            name: $ArrayType.$type,
            properties: {
                elementType: {
                    name: 'elementType'
                }
            },
            superTypes: ['TypeDefinition']
        },
        Assignment: {
            name: $Assignment.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                feature: {
                    name: 'feature'
                },
                lookahead: {
                    name: 'lookahead'
                },
                operator: {
                    name: 'operator'
                },
                predicate: {
                    name: 'predicate'
                },
                terminal: {
                    name: 'terminal'
                }
            },
            superTypes: ['AbstractElement']
        },
        BooleanLiteral: {
            name: $BooleanLiteral.$type,
            properties: {
                true: {
                    name: 'true',
                    defaultValue: false
                }
            },
            superTypes: ['Condition', 'ValueLiteral']
        },
        CharacterRange: {
            name: $CharacterRange.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                left: {
                    name: 'left'
                },
                lookahead: {
                    name: 'lookahead'
                },
                right: {
                    name: 'right'
                }
            },
            superTypes: ['AbstractElement']
        },
        Conjunction: {
            name: $Conjunction.$type,
            properties: {
                left: {
                    name: 'left'
                },
                right: {
                    name: 'right'
                }
            },
            superTypes: ['Condition']
        },
        CrossReference: {
            name: $CrossReference.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                deprecatedSyntax: {
                    name: 'deprecatedSyntax',
                    defaultValue: false
                },
                lookahead: {
                    name: 'lookahead'
                },
                terminal: {
                    name: 'terminal'
                },
                type: {
                    name: 'type',
                    referenceType: 'AbstractType'
                }
            },
            superTypes: ['AbstractElement']
        },
        Disjunction: {
            name: $Disjunction.$type,
            properties: {
                left: {
                    name: 'left'
                },
                right: {
                    name: 'right'
                }
            },
            superTypes: ['Condition']
        },
        EndOfFile: {
            name: $EndOfFile.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                }
            },
            superTypes: ['AbstractElement']
        },
        Grammar: {
            name: $Grammar.$type,
            properties: {
                imports: {
                    name: 'imports',
                    defaultValue: []
                },
                interfaces: {
                    name: 'interfaces',
                    defaultValue: []
                },
                isDeclared: {
                    name: 'isDeclared',
                    defaultValue: false
                },
                name: {
                    name: 'name'
                },
                rules: {
                    name: 'rules',
                    defaultValue: []
                },
                types: {
                    name: 'types',
                    defaultValue: []
                }
            },
            superTypes: []
        },
        GrammarImport: {
            name: $GrammarImport.$type,
            properties: {
                path: {
                    name: 'path'
                }
            },
            superTypes: []
        },
        Group: {
            name: $Group.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                elements: {
                    name: 'elements',
                    defaultValue: []
                },
                guardCondition: {
                    name: 'guardCondition'
                },
                lookahead: {
                    name: 'lookahead'
                },
                predicate: {
                    name: 'predicate'
                }
            },
            superTypes: ['AbstractElement']
        },
        InferredType: {
            name: $InferredType.$type,
            properties: {
                name: {
                    name: 'name'
                }
            },
            superTypes: ['AbstractType']
        },
        InfixRule: {
            name: $InfixRule.$type,
            properties: {
                call: {
                    name: 'call'
                },
                name: {
                    name: 'name'
                },
                operators: {
                    name: 'operators'
                },
                parameters: {
                    name: 'parameters',
                    defaultValue: []
                }
            },
            superTypes: ['AbstractRule', 'AbstractType']
        },
        InfixRuleOperatorList: {
            name: $InfixRuleOperatorList.$type,
            properties: {
                associativity: {
                    name: 'associativity'
                },
                operators: {
                    name: 'operators',
                    defaultValue: []
                }
            },
            superTypes: []
        },
        InfixRuleOperators: {
            name: $InfixRuleOperators.$type,
            properties: {
                precedences: {
                    name: 'precedences',
                    defaultValue: []
                }
            },
            superTypes: []
        },
        Interface: {
            name: $Interface.$type,
            properties: {
                attributes: {
                    name: 'attributes',
                    defaultValue: []
                },
                name: {
                    name: 'name'
                },
                superTypes: {
                    name: 'superTypes',
                    defaultValue: [],
                    referenceType: 'AbstractType'
                }
            },
            superTypes: ['AbstractType']
        },
        Keyword: {
            name: $Keyword.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                },
                predicate: {
                    name: 'predicate'
                },
                value: {
                    name: 'value'
                }
            },
            superTypes: ['AbstractElement']
        },
        NamedArgument: {
            name: $NamedArgument.$type,
            properties: {
                calledByName: {
                    name: 'calledByName',
                    defaultValue: false
                },
                parameter: {
                    name: 'parameter',
                    referenceType: 'Parameter'
                },
                value: {
                    name: 'value'
                }
            },
            superTypes: []
        },
        NegatedToken: {
            name: $NegatedToken.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                },
                terminal: {
                    name: 'terminal'
                }
            },
            superTypes: ['AbstractElement']
        },
        Negation: {
            name: $Negation.$type,
            properties: {
                value: {
                    name: 'value'
                }
            },
            superTypes: ['Condition']
        },
        NumberLiteral: {
            name: $NumberLiteral.$type,
            properties: {
                value: {
                    name: 'value'
                }
            },
            superTypes: ['ValueLiteral']
        },
        Parameter: {
            name: $Parameter.$type,
            properties: {
                name: {
                    name: 'name'
                }
            },
            superTypes: []
        },
        ParameterReference: {
            name: $ParameterReference.$type,
            properties: {
                parameter: {
                    name: 'parameter',
                    referenceType: 'Parameter'
                }
            },
            superTypes: ['Condition']
        },
        ParserRule: {
            name: $ParserRule.$type,
            properties: {
                dataType: {
                    name: 'dataType'
                },
                definition: {
                    name: 'definition'
                },
                entry: {
                    name: 'entry',
                    defaultValue: false
                },
                fragment: {
                    name: 'fragment',
                    defaultValue: false
                },
                inferredType: {
                    name: 'inferredType'
                },
                name: {
                    name: 'name'
                },
                parameters: {
                    name: 'parameters',
                    defaultValue: []
                },
                returnType: {
                    name: 'returnType',
                    referenceType: 'AbstractType'
                }
            },
            superTypes: ['AbstractRule', 'AbstractType']
        },
        ReferenceType: {
            name: $ReferenceType.$type,
            properties: {
                referenceType: {
                    name: 'referenceType'
                }
            },
            superTypes: ['TypeDefinition']
        },
        RegexToken: {
            name: $RegexToken.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                },
                regex: {
                    name: 'regex'
                }
            },
            superTypes: ['AbstractElement']
        },
        ReturnType: {
            name: $ReturnType.$type,
            properties: {
                name: {
                    name: 'name'
                }
            },
            superTypes: []
        },
        RuleCall: {
            name: $RuleCall.$type,
            properties: {
                arguments: {
                    name: 'arguments',
                    defaultValue: []
                },
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                },
                predicate: {
                    name: 'predicate'
                },
                rule: {
                    name: 'rule',
                    referenceType: 'AbstractRule'
                }
            },
            superTypes: ['AbstractElement']
        },
        SimpleType: {
            name: $SimpleType.$type,
            properties: {
                primitiveType: {
                    name: 'primitiveType'
                },
                stringType: {
                    name: 'stringType'
                },
                typeRef: {
                    name: 'typeRef',
                    referenceType: 'AbstractType'
                }
            },
            superTypes: ['TypeDefinition']
        },
        StringLiteral: {
            name: $StringLiteral.$type,
            properties: {
                value: {
                    name: 'value'
                }
            },
            superTypes: ['ValueLiteral']
        },
        TerminalAlternatives: {
            name: $TerminalAlternatives.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                elements: {
                    name: 'elements',
                    defaultValue: []
                },
                lookahead: {
                    name: 'lookahead'
                }
            },
            superTypes: ['AbstractElement']
        },
        TerminalGroup: {
            name: $TerminalGroup.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                elements: {
                    name: 'elements',
                    defaultValue: []
                },
                lookahead: {
                    name: 'lookahead'
                }
            },
            superTypes: ['AbstractElement']
        },
        TerminalRule: {
            name: $TerminalRule.$type,
            properties: {
                definition: {
                    name: 'definition'
                },
                fragment: {
                    name: 'fragment',
                    defaultValue: false
                },
                hidden: {
                    name: 'hidden',
                    defaultValue: false
                },
                name: {
                    name: 'name'
                },
                type: {
                    name: 'type'
                }
            },
            superTypes: ['AbstractRule']
        },
        TerminalRuleCall: {
            name: $TerminalRuleCall.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                },
                rule: {
                    name: 'rule',
                    referenceType: 'TerminalRule'
                }
            },
            superTypes: ['AbstractElement']
        },
        Type: {
            name: $Type.$type,
            properties: {
                name: {
                    name: 'name'
                },
                type: {
                    name: 'type'
                }
            },
            superTypes: ['AbstractType']
        },
        TypeAttribute: {
            name: $TypeAttribute.$type,
            properties: {
                defaultValue: {
                    name: 'defaultValue'
                },
                isOptional: {
                    name: 'isOptional',
                    defaultValue: false
                },
                name: {
                    name: 'name'
                },
                type: {
                    name: 'type'
                }
            },
            superTypes: []
        },
        UnionType: {
            name: $UnionType.$type,
            properties: {
                types: {
                    name: 'types',
                    defaultValue: []
                }
            },
            superTypes: ['TypeDefinition']
        },
        UnorderedGroup: {
            name: $UnorderedGroup.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                elements: {
                    name: 'elements',
                    defaultValue: []
                },
                lookahead: {
                    name: 'lookahead'
                }
            },
            superTypes: ['AbstractElement']
        },
        UntilToken: {
            name: $UntilToken.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                },
                terminal: {
                    name: 'terminal'
                }
            },
            superTypes: ['AbstractElement']
        },
        Wildcard: {
            name: $Wildcard.$type,
            properties: {
                cardinality: {
                    name: 'cardinality'
                },
                lookahead: {
                    name: 'lookahead'
                }
            },
            superTypes: ['AbstractElement']
        }
    } as const satisfies langium.AstMetaData
}

export const reflection = new LangiumGrammarAstReflection();

/******************************************************************************
 * This file was generated by langium-cli 4.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from '../../syntax-tree.js';

export const LangiumGrammarTerminals = {
    ID: /\^?[_a-zA-Z][\w_]*/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    NUMBER: /NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity)/,
    RegexLiteral: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\/[a-z]*/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type LangiumGrammarTerminalNames = keyof typeof LangiumGrammarTerminals;

export type LangiumGrammarKeywordNames =
    | "!"
    | "&"
    | "("
    | ")"
    | "*"
    | "+"
    | "+="
    | ","
    | "->"
    | "."
    | ".."
    | ":"
    | ";"
    | "<"
    | "="
    | "=>"
    | ">"
    | "?"
    | "?!"
    | "?<!"
    | "?<="
    | "?="
    | "@"
    | "Date"
    | "EOF"
    | "["
    | "]"
    | "assoc"
    | "bigint"
    | "boolean"
    | "current"
    | "entry"
    | "extends"
    | "false"
    | "fragment"
    | "grammar"
    | "hidden"
    | "import"
    | "infer"
    | "infers"
    | "infix"
    | "interface"
    | "left"
    | "number"
    | "on"
    | "returns"
    | "right"
    | "string"
    | "terminal"
    | "true"
    | "type"
    | "with"
    | "{"
    | "|"
    | "}";

export type LangiumGrammarTokenNames = LangiumGrammarTerminalNames | LangiumGrammarKeywordNames;

export interface AbstractElement extends langium.AstNode {
    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'EndOfFile' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalElement' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';
    cardinality?: '*' | '+' | '?';
}

export const AbstractElement = {
    $type: 'AbstractElement',
    cardinality: 'cardinality'
} as const;

export function isAbstractElement(item: unknown): item is AbstractElement {
    return reflection.isInstance(item, AbstractElement.$type);
}

export type AbstractParserRule = InfixRule | ParserRule;

export const AbstractParserRule = {
    $type: 'AbstractParserRule'
} as const;

export function isAbstractParserRule(item: unknown): item is AbstractParserRule {
    return reflection.isInstance(item, AbstractParserRule.$type);
}

export type AbstractRule = AbstractParserRule | TerminalRule;

export const AbstractRule = {
    $type: 'AbstractRule'
} as const;

export function isAbstractRule(item: unknown): item is AbstractRule {
    return reflection.isInstance(item, AbstractRule.$type);
}

export type AbstractType = AbstractParserRule | InferredType | Interface | Type;

export const AbstractType = {
    $type: 'AbstractType'
} as const;

export function isAbstractType(item: unknown): item is AbstractType {
    return reflection.isInstance(item, AbstractType.$type);
}

export interface Action extends AbstractElement {
    readonly $type: 'Action';
    feature?: FeatureName;
    inferredType?: InferredType;
    operator?: '+=' | '=';
    type?: langium.Reference<AbstractType>;
}

export const Action = {
    $type: 'Action',
    cardinality: 'cardinality',
    feature: 'feature',
    inferredType: 'inferredType',
    operator: 'operator',
    type: 'type'
} as const;

export function isAction(item: unknown): item is Action {
    return reflection.isInstance(item, Action.$type);
}

export interface Alternatives extends AbstractElement {
    readonly $type: 'Alternatives';
    elements: Array<AbstractElement>;
}

export const Alternatives = {
    $type: 'Alternatives',
    cardinality: 'cardinality',
    elements: 'elements'
} as const;

export function isAlternatives(item: unknown): item is Alternatives {
    return reflection.isInstance(item, Alternatives.$type);
}

export interface ArrayLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'ArrayLiteral';
    elements: Array<ValueLiteral>;
}

export const ArrayLiteral = {
    $type: 'ArrayLiteral',
    elements: 'elements'
} as const;

export function isArrayLiteral(item: unknown): item is ArrayLiteral {
    return reflection.isInstance(item, ArrayLiteral.$type);
}

export interface ArrayType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ArrayType';
    elementType: TypeDefinition;
}

export const ArrayType = {
    $type: 'ArrayType',
    elementType: 'elementType'
} as const;

export function isArrayType(item: unknown): item is ArrayType {
    return reflection.isInstance(item, ArrayType.$type);
}

export interface Assignment extends AbstractElement {
    readonly $type: 'Assignment';
    feature: FeatureName;
    operator: '+=' | '=' | '?=';
    predicate?: '->' | '=>';
    terminal: AbstractElement;
}

export const Assignment = {
    $type: 'Assignment',
    cardinality: 'cardinality',
    feature: 'feature',
    operator: 'operator',
    predicate: 'predicate',
    terminal: 'terminal'
} as const;

export function isAssignment(item: unknown): item is Assignment {
    return reflection.isInstance(item, Assignment.$type);
}

export type Associativity = 'left' | 'right';

export interface BooleanLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | Conjunction | Disjunction | Group | NamedArgument | Negation | TypeAttribute;
    readonly $type: 'BooleanLiteral';
    true: boolean;
}

export const BooleanLiteral = {
    $type: 'BooleanLiteral',
    true: 'true'
} as const;

export function isBooleanLiteral(item: unknown): item is BooleanLiteral {
    return reflection.isInstance(item, BooleanLiteral.$type);
}

export interface CharacterRange extends TerminalElement {
    readonly $type: 'CharacterRange';
    left: Keyword;
    right?: Keyword;
}

export const CharacterRange = {
    $type: 'CharacterRange',
    cardinality: 'cardinality',
    left: 'left',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized',
    right: 'right'
} as const;

export function isCharacterRange(item: unknown): item is CharacterRange {
    return reflection.isInstance(item, CharacterRange.$type);
}

export type Condition = BooleanLiteral | Conjunction | Disjunction | Negation | ParameterReference;

export const Condition = {
    $type: 'Condition'
} as const;

export function isCondition(item: unknown): item is Condition {
    return reflection.isInstance(item, Condition.$type);
}

export interface Conjunction extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Conjunction';
    left: Condition;
    right: Condition;
}

export const Conjunction = {
    $type: 'Conjunction',
    left: 'left',
    right: 'right'
} as const;

export function isConjunction(item: unknown): item is Conjunction {
    return reflection.isInstance(item, Conjunction.$type);
}

export interface CrossReference extends AbstractElement {
    readonly $type: 'CrossReference';
    deprecatedSyntax: boolean;
    isMulti: boolean;
    terminal?: AbstractElement;
    type: langium.Reference<AbstractType>;
}

export const CrossReference = {
    $type: 'CrossReference',
    cardinality: 'cardinality',
    deprecatedSyntax: 'deprecatedSyntax',
    isMulti: 'isMulti',
    terminal: 'terminal',
    type: 'type'
} as const;

export function isCrossReference(item: unknown): item is CrossReference {
    return reflection.isInstance(item, CrossReference.$type);
}

export interface Disjunction extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Disjunction';
    left: Condition;
    right: Condition;
}

export const Disjunction = {
    $type: 'Disjunction',
    left: 'left',
    right: 'right'
} as const;

export function isDisjunction(item: unknown): item is Disjunction {
    return reflection.isInstance(item, Disjunction.$type);
}

export interface EndOfFile extends AbstractElement {
    readonly $type: 'EndOfFile';
}

export const EndOfFile = {
    $type: 'EndOfFile',
    cardinality: 'cardinality'
} as const;

export function isEndOfFile(item: unknown): item is EndOfFile {
    return reflection.isInstance(item, EndOfFile.$type);
}

export type FeatureName = 'assoc' | 'current' | 'entry' | 'extends' | 'false' | 'fragment' | 'grammar' | 'hidden' | 'import' | 'infer' | 'infers' | 'infix' | 'interface' | 'left' | 'on' | 'returns' | 'right' | 'terminal' | 'true' | 'type' | 'with' | PrimitiveType | string;

export interface Grammar extends langium.AstNode {
    readonly $type: 'Grammar';
    imports: Array<GrammarImport>;
    interfaces: Array<Interface>;
    isDeclared: boolean;
    name?: string;
    rules: Array<AbstractRule>;
    types: Array<Type>;
}

export const Grammar = {
    $type: 'Grammar',
    imports: 'imports',
    interfaces: 'interfaces',
    isDeclared: 'isDeclared',
    name: 'name',
    rules: 'rules',
    types: 'types'
} as const;

export function isGrammar(item: unknown): item is Grammar {
    return reflection.isInstance(item, Grammar.$type);
}

export interface GrammarImport extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'GrammarImport';
    path: string;
}

export const GrammarImport = {
    $type: 'GrammarImport',
    path: 'path'
} as const;

export function isGrammarImport(item: unknown): item is GrammarImport {
    return reflection.isInstance(item, GrammarImport.$type);
}

export interface Group extends AbstractElement {
    readonly $type: 'Group';
    elements: Array<AbstractElement>;
    guardCondition?: Condition;
    predicate?: '->' | '=>';
}

export const Group = {
    $type: 'Group',
    cardinality: 'cardinality',
    elements: 'elements',
    guardCondition: 'guardCondition',
    predicate: 'predicate'
} as const;

export function isGroup(item: unknown): item is Group {
    return reflection.isInstance(item, Group.$type);
}

export interface InferredType extends langium.AstNode {
    readonly $container: Action | InfixRule | ParserRule;
    readonly $type: 'InferredType';
    name: string;
}

export const InferredType = {
    $type: 'InferredType',
    name: 'name'
} as const;

export function isInferredType(item: unknown): item is InferredType {
    return reflection.isInstance(item, InferredType.$type);
}

export interface InfixRule extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'InfixRule';
    call: RuleCall;
    dataType?: PrimitiveType;
    inferredType?: InferredType;
    name: string;
    operators: InfixRuleOperators;
    parameters: Array<Parameter>;
    returnType?: langium.Reference<AbstractType>;
}

export const InfixRule = {
    $type: 'InfixRule',
    call: 'call',
    dataType: 'dataType',
    inferredType: 'inferredType',
    name: 'name',
    operators: 'operators',
    parameters: 'parameters',
    returnType: 'returnType'
} as const;

export function isInfixRule(item: unknown): item is InfixRule {
    return reflection.isInstance(item, InfixRule.$type);
}

export interface InfixRuleOperatorList extends langium.AstNode {
    readonly $container: InfixRuleOperators;
    readonly $type: 'InfixRuleOperatorList';
    associativity?: Associativity;
    operators: Array<Keyword>;
}

export const InfixRuleOperatorList = {
    $type: 'InfixRuleOperatorList',
    associativity: 'associativity',
    operators: 'operators'
} as const;

export function isInfixRuleOperatorList(item: unknown): item is InfixRuleOperatorList {
    return reflection.isInstance(item, InfixRuleOperatorList.$type);
}

export interface InfixRuleOperators extends langium.AstNode {
    readonly $container: InfixRule;
    readonly $type: 'InfixRuleOperators';
    precedences: Array<InfixRuleOperatorList>;
}

export const InfixRuleOperators = {
    $type: 'InfixRuleOperators',
    precedences: 'precedences'
} as const;

export function isInfixRuleOperators(item: unknown): item is InfixRuleOperators {
    return reflection.isInstance(item, InfixRuleOperators.$type);
}

export interface Interface extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'Interface';
    attributes: Array<TypeAttribute>;
    name: string;
    superTypes: Array<langium.Reference<AbstractType>>;
}

export const Interface = {
    $type: 'Interface',
    attributes: 'attributes',
    name: 'name',
    superTypes: 'superTypes'
} as const;

export function isInterface(item: unknown): item is Interface {
    return reflection.isInstance(item, Interface.$type);
}

export interface Keyword extends AbstractElement {
    readonly $container: CharacterRange | InfixRuleOperatorList;
    readonly $type: 'Keyword';
    predicate?: '->' | '=>';
    value: string;
}

export const Keyword = {
    $type: 'Keyword',
    cardinality: 'cardinality',
    predicate: 'predicate',
    value: 'value'
} as const;

export function isKeyword(item: unknown): item is Keyword {
    return reflection.isInstance(item, Keyword.$type);
}

export interface NamedArgument extends langium.AstNode {
    readonly $container: RuleCall;
    readonly $type: 'NamedArgument';
    calledByName: boolean;
    parameter?: langium.Reference<Parameter>;
    value: Condition;
}

export const NamedArgument = {
    $type: 'NamedArgument',
    calledByName: 'calledByName',
    parameter: 'parameter',
    value: 'value'
} as const;

export function isNamedArgument(item: unknown): item is NamedArgument {
    return reflection.isInstance(item, NamedArgument.$type);
}

export interface NegatedToken extends TerminalElement {
    readonly $type: 'NegatedToken';
    terminal: AbstractElement;
}

export const NegatedToken = {
    $type: 'NegatedToken',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized',
    terminal: 'terminal'
} as const;

export function isNegatedToken(item: unknown): item is NegatedToken {
    return reflection.isInstance(item, NegatedToken.$type);
}

export interface Negation extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Negation';
    value: Condition;
}

export const Negation = {
    $type: 'Negation',
    value: 'value'
} as const;

export function isNegation(item: unknown): item is Negation {
    return reflection.isInstance(item, Negation.$type);
}

export interface NumberLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'NumberLiteral';
    value: number;
}

export const NumberLiteral = {
    $type: 'NumberLiteral',
    value: 'value'
} as const;

export function isNumberLiteral(item: unknown): item is NumberLiteral {
    return reflection.isInstance(item, NumberLiteral.$type);
}

export interface Parameter extends langium.AstNode {
    readonly $container: InfixRule | ParserRule;
    readonly $type: 'Parameter';
    name: string;
}

export const Parameter = {
    $type: 'Parameter',
    name: 'name'
} as const;

export function isParameter(item: unknown): item is Parameter {
    return reflection.isInstance(item, Parameter.$type);
}

export interface ParameterReference extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'ParameterReference';
    parameter: langium.Reference<Parameter>;
}

export const ParameterReference = {
    $type: 'ParameterReference',
    parameter: 'parameter'
} as const;

export function isParameterReference(item: unknown): item is ParameterReference {
    return reflection.isInstance(item, ParameterReference.$type);
}

export interface ParserRule extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'ParserRule';
    dataType?: PrimitiveType;
    definition: AbstractElement;
    entry: boolean;
    fragment: boolean;
    inferredType?: InferredType;
    name: string;
    parameters: Array<Parameter>;
    returnType?: langium.Reference<AbstractType>;
}

export const ParserRule = {
    $type: 'ParserRule',
    dataType: 'dataType',
    definition: 'definition',
    entry: 'entry',
    fragment: 'fragment',
    inferredType: 'inferredType',
    name: 'name',
    parameters: 'parameters',
    returnType: 'returnType'
} as const;

export function isParserRule(item: unknown): item is ParserRule {
    return reflection.isInstance(item, ParserRule.$type);
}

export type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';

export interface ReferenceType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ReferenceType';
    isMulti: boolean;
    referenceType: TypeDefinition;
}

export const ReferenceType = {
    $type: 'ReferenceType',
    isMulti: 'isMulti',
    referenceType: 'referenceType'
} as const;

export function isReferenceType(item: unknown): item is ReferenceType {
    return reflection.isInstance(item, ReferenceType.$type);
}

export interface RegexToken extends TerminalElement {
    readonly $type: 'RegexToken';
    regex: string;
}

export const RegexToken = {
    $type: 'RegexToken',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized',
    regex: 'regex'
} as const;

export function isRegexToken(item: unknown): item is RegexToken {
    return reflection.isInstance(item, RegexToken.$type);
}

export interface ReturnType extends langium.AstNode {
    readonly $container: TerminalRule;
    readonly $type: 'ReturnType';
    name: PrimitiveType | string;
}

export const ReturnType = {
    $type: 'ReturnType',
    name: 'name'
} as const;

export function isReturnType(item: unknown): item is ReturnType {
    return reflection.isInstance(item, ReturnType.$type);
}

export interface RuleCall extends AbstractElement {
    readonly $container: InfixRule;
    readonly $type: 'RuleCall';
    arguments: Array<NamedArgument>;
    predicate?: '->' | '=>';
    rule: langium.Reference<AbstractRule>;
}

export const RuleCall = {
    $type: 'RuleCall',
    arguments: 'arguments',
    cardinality: 'cardinality',
    predicate: 'predicate',
    rule: 'rule'
} as const;

export function isRuleCall(item: unknown): item is RuleCall {
    return reflection.isInstance(item, RuleCall.$type);
}

export interface SimpleType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'SimpleType';
    primitiveType?: PrimitiveType;
    stringType?: string;
    typeRef?: langium.Reference<AbstractType>;
}

export const SimpleType = {
    $type: 'SimpleType',
    primitiveType: 'primitiveType',
    stringType: 'stringType',
    typeRef: 'typeRef'
} as const;

export function isSimpleType(item: unknown): item is SimpleType {
    return reflection.isInstance(item, SimpleType.$type);
}

export interface StringLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'StringLiteral';
    value: string;
}

export const StringLiteral = {
    $type: 'StringLiteral',
    value: 'value'
} as const;

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, StringLiteral.$type);
}

export interface TerminalAlternatives extends TerminalElement {
    readonly $type: 'TerminalAlternatives';
    elements: Array<AbstractElement>;
}

export const TerminalAlternatives = {
    $type: 'TerminalAlternatives',
    cardinality: 'cardinality',
    elements: 'elements',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized'
} as const;

export function isTerminalAlternatives(item: unknown): item is TerminalAlternatives {
    return reflection.isInstance(item, TerminalAlternatives.$type);
}

export interface TerminalElement extends AbstractElement {
    readonly $type: 'CharacterRange' | 'NegatedToken' | 'RegexToken' | 'TerminalAlternatives' | 'TerminalElement' | 'TerminalGroup' | 'TerminalRuleCall' | 'UntilToken' | 'Wildcard';
    lookahead?: '?!' | '?<!' | '?<=' | '?=';
    parenthesized: boolean;
}

export const TerminalElement = {
    $type: 'TerminalElement',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized'
} as const;

export function isTerminalElement(item: unknown): item is TerminalElement {
    return reflection.isInstance(item, TerminalElement.$type);
}

export interface TerminalGroup extends TerminalElement {
    readonly $type: 'TerminalGroup';
    elements: Array<AbstractElement>;
}

export const TerminalGroup = {
    $type: 'TerminalGroup',
    cardinality: 'cardinality',
    elements: 'elements',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized'
} as const;

export function isTerminalGroup(item: unknown): item is TerminalGroup {
    return reflection.isInstance(item, TerminalGroup.$type);
}

export interface TerminalRule extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'TerminalRule';
    definition: TerminalElement;
    fragment: boolean;
    hidden: boolean;
    name: string;
    type?: ReturnType;
}

export const TerminalRule = {
    $type: 'TerminalRule',
    definition: 'definition',
    fragment: 'fragment',
    hidden: 'hidden',
    name: 'name',
    type: 'type'
} as const;

export function isTerminalRule(item: unknown): item is TerminalRule {
    return reflection.isInstance(item, TerminalRule.$type);
}

export interface TerminalRuleCall extends TerminalElement {
    readonly $type: 'TerminalRuleCall';
    rule: langium.Reference<TerminalRule>;
}

export const TerminalRuleCall = {
    $type: 'TerminalRuleCall',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized',
    rule: 'rule'
} as const;

export function isTerminalRuleCall(item: unknown): item is TerminalRuleCall {
    return reflection.isInstance(item, TerminalRuleCall.$type);
}

export interface Type extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'Type';
    name: string;
    type: TypeDefinition;
}

export const Type = {
    $type: 'Type',
    name: 'name',
    type: 'type'
} as const;

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type.$type);
}

export interface TypeAttribute extends langium.AstNode {
    readonly $container: Interface;
    readonly $type: 'TypeAttribute';
    defaultValue?: ValueLiteral;
    isOptional: boolean;
    name: FeatureName;
    type: TypeDefinition;
}

export const TypeAttribute = {
    $type: 'TypeAttribute',
    defaultValue: 'defaultValue',
    isOptional: 'isOptional',
    name: 'name',
    type: 'type'
} as const;

export function isTypeAttribute(item: unknown): item is TypeAttribute {
    return reflection.isInstance(item, TypeAttribute.$type);
}

export type TypeDefinition = ArrayType | ReferenceType | SimpleType | UnionType;

export const TypeDefinition = {
    $type: 'TypeDefinition'
} as const;

export function isTypeDefinition(item: unknown): item is TypeDefinition {
    return reflection.isInstance(item, TypeDefinition.$type);
}

export interface UnionType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'UnionType';
    types: Array<TypeDefinition>;
}

export const UnionType = {
    $type: 'UnionType',
    types: 'types'
} as const;

export function isUnionType(item: unknown): item is UnionType {
    return reflection.isInstance(item, UnionType.$type);
}

export interface UnorderedGroup extends AbstractElement {
    readonly $type: 'UnorderedGroup';
    elements: Array<AbstractElement>;
}

export const UnorderedGroup = {
    $type: 'UnorderedGroup',
    cardinality: 'cardinality',
    elements: 'elements'
} as const;

export function isUnorderedGroup(item: unknown): item is UnorderedGroup {
    return reflection.isInstance(item, UnorderedGroup.$type);
}

export interface UntilToken extends TerminalElement {
    readonly $type: 'UntilToken';
    terminal: AbstractElement;
}

export const UntilToken = {
    $type: 'UntilToken',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized',
    terminal: 'terminal'
} as const;

export function isUntilToken(item: unknown): item is UntilToken {
    return reflection.isInstance(item, UntilToken.$type);
}

export type ValueLiteral = ArrayLiteral | BooleanLiteral | NumberLiteral | StringLiteral;

export const ValueLiteral = {
    $type: 'ValueLiteral'
} as const;

export function isValueLiteral(item: unknown): item is ValueLiteral {
    return reflection.isInstance(item, ValueLiteral.$type);
}

export interface Wildcard extends TerminalElement {
    readonly $type: 'Wildcard';
}

export const Wildcard = {
    $type: 'Wildcard',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized'
} as const;

export function isWildcard(item: unknown): item is Wildcard {
    return reflection.isInstance(item, Wildcard.$type);
}

export type LangiumGrammarAstType = {
    AbstractElement: AbstractElement
    AbstractParserRule: AbstractParserRule
    AbstractRule: AbstractRule
    AbstractType: AbstractType
    Action: Action
    Alternatives: Alternatives
    ArrayLiteral: ArrayLiteral
    ArrayType: ArrayType
    Assignment: Assignment
    BooleanLiteral: BooleanLiteral
    CharacterRange: CharacterRange
    Condition: Condition
    Conjunction: Conjunction
    CrossReference: CrossReference
    Disjunction: Disjunction
    EndOfFile: EndOfFile
    Grammar: Grammar
    GrammarImport: GrammarImport
    Group: Group
    InferredType: InferredType
    InfixRule: InfixRule
    InfixRuleOperatorList: InfixRuleOperatorList
    InfixRuleOperators: InfixRuleOperators
    Interface: Interface
    Keyword: Keyword
    NamedArgument: NamedArgument
    NegatedToken: NegatedToken
    Negation: Negation
    NumberLiteral: NumberLiteral
    Parameter: Parameter
    ParameterReference: ParameterReference
    ParserRule: ParserRule
    ReferenceType: ReferenceType
    RegexToken: RegexToken
    ReturnType: ReturnType
    RuleCall: RuleCall
    SimpleType: SimpleType
    StringLiteral: StringLiteral
    TerminalAlternatives: TerminalAlternatives
    TerminalElement: TerminalElement
    TerminalGroup: TerminalGroup
    TerminalRule: TerminalRule
    TerminalRuleCall: TerminalRuleCall
    Type: Type
    TypeAttribute: TypeAttribute
    TypeDefinition: TypeDefinition
    UnionType: UnionType
    UnorderedGroup: UnorderedGroup
    UntilToken: UntilToken
    ValueLiteral: ValueLiteral
    Wildcard: Wildcard
}

export class LangiumGrammarAstReflection extends langium.AbstractAstReflection {
    override readonly types = {
        AbstractElement: {
            name: AbstractElement.$type,
            properties: {
                cardinality: {
                    name: AbstractElement.cardinality
                }
            },
            superTypes: []
        },
        AbstractParserRule: {
            name: AbstractParserRule.$type,
            properties: {
            },
            superTypes: [AbstractRule.$type, AbstractType.$type]
        },
        AbstractRule: {
            name: AbstractRule.$type,
            properties: {
            },
            superTypes: []
        },
        AbstractType: {
            name: AbstractType.$type,
            properties: {
            },
            superTypes: []
        },
        Action: {
            name: Action.$type,
            properties: {
                cardinality: {
                    name: Action.cardinality
                },
                feature: {
                    name: Action.feature
                },
                inferredType: {
                    name: Action.inferredType
                },
                operator: {
                    name: Action.operator
                },
                type: {
                    name: Action.type,
                    referenceType: AbstractType.$type
                }
            },
            superTypes: [AbstractElement.$type]
        },
        Alternatives: {
            name: Alternatives.$type,
            properties: {
                cardinality: {
                    name: Alternatives.cardinality
                },
                elements: {
                    name: Alternatives.elements,
                    defaultValue: []
                }
            },
            superTypes: [AbstractElement.$type]
        },
        ArrayLiteral: {
            name: ArrayLiteral.$type,
            properties: {
                elements: {
                    name: ArrayLiteral.elements,
                    defaultValue: []
                }
            },
            superTypes: [ValueLiteral.$type]
        },
        ArrayType: {
            name: ArrayType.$type,
            properties: {
                elementType: {
                    name: ArrayType.elementType
                }
            },
            superTypes: [TypeDefinition.$type]
        },
        Assignment: {
            name: Assignment.$type,
            properties: {
                cardinality: {
                    name: Assignment.cardinality
                },
                feature: {
                    name: Assignment.feature
                },
                operator: {
                    name: Assignment.operator
                },
                predicate: {
                    name: Assignment.predicate
                },
                terminal: {
                    name: Assignment.terminal
                }
            },
            superTypes: [AbstractElement.$type]
        },
        BooleanLiteral: {
            name: BooleanLiteral.$type,
            properties: {
                true: {
                    name: BooleanLiteral.true,
                    defaultValue: false
                }
            },
            superTypes: [Condition.$type, ValueLiteral.$type]
        },
        CharacterRange: {
            name: CharacterRange.$type,
            properties: {
                cardinality: {
                    name: CharacterRange.cardinality
                },
                left: {
                    name: CharacterRange.left
                },
                lookahead: {
                    name: CharacterRange.lookahead
                },
                parenthesized: {
                    name: CharacterRange.parenthesized,
                    defaultValue: false
                },
                right: {
                    name: CharacterRange.right
                }
            },
            superTypes: [TerminalElement.$type]
        },
        Condition: {
            name: Condition.$type,
            properties: {
            },
            superTypes: []
        },
        Conjunction: {
            name: Conjunction.$type,
            properties: {
                left: {
                    name: Conjunction.left
                },
                right: {
                    name: Conjunction.right
                }
            },
            superTypes: [Condition.$type]
        },
        CrossReference: {
            name: CrossReference.$type,
            properties: {
                cardinality: {
                    name: CrossReference.cardinality
                },
                deprecatedSyntax: {
                    name: CrossReference.deprecatedSyntax,
                    defaultValue: false
                },
                isMulti: {
                    name: CrossReference.isMulti,
                    defaultValue: false
                },
                terminal: {
                    name: CrossReference.terminal
                },
                type: {
                    name: CrossReference.type,
                    referenceType: AbstractType.$type
                }
            },
            superTypes: [AbstractElement.$type]
        },
        Disjunction: {
            name: Disjunction.$type,
            properties: {
                left: {
                    name: Disjunction.left
                },
                right: {
                    name: Disjunction.right
                }
            },
            superTypes: [Condition.$type]
        },
        EndOfFile: {
            name: EndOfFile.$type,
            properties: {
                cardinality: {
                    name: EndOfFile.cardinality
                }
            },
            superTypes: [AbstractElement.$type]
        },
        Grammar: {
            name: Grammar.$type,
            properties: {
                imports: {
                    name: Grammar.imports,
                    defaultValue: []
                },
                interfaces: {
                    name: Grammar.interfaces,
                    defaultValue: []
                },
                isDeclared: {
                    name: Grammar.isDeclared,
                    defaultValue: false
                },
                name: {
                    name: Grammar.name
                },
                rules: {
                    name: Grammar.rules,
                    defaultValue: []
                },
                types: {
                    name: Grammar.types,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        GrammarImport: {
            name: GrammarImport.$type,
            properties: {
                path: {
                    name: GrammarImport.path
                }
            },
            superTypes: []
        },
        Group: {
            name: Group.$type,
            properties: {
                cardinality: {
                    name: Group.cardinality
                },
                elements: {
                    name: Group.elements,
                    defaultValue: []
                },
                guardCondition: {
                    name: Group.guardCondition
                },
                predicate: {
                    name: Group.predicate
                }
            },
            superTypes: [AbstractElement.$type]
        },
        InferredType: {
            name: InferredType.$type,
            properties: {
                name: {
                    name: InferredType.name
                }
            },
            superTypes: [AbstractType.$type]
        },
        InfixRule: {
            name: InfixRule.$type,
            properties: {
                call: {
                    name: InfixRule.call
                },
                dataType: {
                    name: InfixRule.dataType
                },
                inferredType: {
                    name: InfixRule.inferredType
                },
                name: {
                    name: InfixRule.name
                },
                operators: {
                    name: InfixRule.operators
                },
                parameters: {
                    name: InfixRule.parameters,
                    defaultValue: []
                },
                returnType: {
                    name: InfixRule.returnType,
                    referenceType: AbstractType.$type
                }
            },
            superTypes: [AbstractParserRule.$type]
        },
        InfixRuleOperatorList: {
            name: InfixRuleOperatorList.$type,
            properties: {
                associativity: {
                    name: InfixRuleOperatorList.associativity
                },
                operators: {
                    name: InfixRuleOperatorList.operators,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        InfixRuleOperators: {
            name: InfixRuleOperators.$type,
            properties: {
                precedences: {
                    name: InfixRuleOperators.precedences,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        Interface: {
            name: Interface.$type,
            properties: {
                attributes: {
                    name: Interface.attributes,
                    defaultValue: []
                },
                name: {
                    name: Interface.name
                },
                superTypes: {
                    name: Interface.superTypes,
                    defaultValue: [],
                    referenceType: AbstractType.$type
                }
            },
            superTypes: [AbstractType.$type]
        },
        Keyword: {
            name: Keyword.$type,
            properties: {
                cardinality: {
                    name: Keyword.cardinality
                },
                predicate: {
                    name: Keyword.predicate
                },
                value: {
                    name: Keyword.value
                }
            },
            superTypes: [AbstractElement.$type]
        },
        NamedArgument: {
            name: NamedArgument.$type,
            properties: {
                calledByName: {
                    name: NamedArgument.calledByName,
                    defaultValue: false
                },
                parameter: {
                    name: NamedArgument.parameter,
                    referenceType: Parameter.$type
                },
                value: {
                    name: NamedArgument.value
                }
            },
            superTypes: []
        },
        NegatedToken: {
            name: NegatedToken.$type,
            properties: {
                cardinality: {
                    name: NegatedToken.cardinality
                },
                lookahead: {
                    name: NegatedToken.lookahead
                },
                parenthesized: {
                    name: NegatedToken.parenthesized,
                    defaultValue: false
                },
                terminal: {
                    name: NegatedToken.terminal
                }
            },
            superTypes: [TerminalElement.$type]
        },
        Negation: {
            name: Negation.$type,
            properties: {
                value: {
                    name: Negation.value
                }
            },
            superTypes: [Condition.$type]
        },
        NumberLiteral: {
            name: NumberLiteral.$type,
            properties: {
                value: {
                    name: NumberLiteral.value
                }
            },
            superTypes: [ValueLiteral.$type]
        },
        Parameter: {
            name: Parameter.$type,
            properties: {
                name: {
                    name: Parameter.name
                }
            },
            superTypes: []
        },
        ParameterReference: {
            name: ParameterReference.$type,
            properties: {
                parameter: {
                    name: ParameterReference.parameter,
                    referenceType: Parameter.$type
                }
            },
            superTypes: [Condition.$type]
        },
        ParserRule: {
            name: ParserRule.$type,
            properties: {
                dataType: {
                    name: ParserRule.dataType
                },
                definition: {
                    name: ParserRule.definition
                },
                entry: {
                    name: ParserRule.entry,
                    defaultValue: false
                },
                fragment: {
                    name: ParserRule.fragment,
                    defaultValue: false
                },
                inferredType: {
                    name: ParserRule.inferredType
                },
                name: {
                    name: ParserRule.name
                },
                parameters: {
                    name: ParserRule.parameters,
                    defaultValue: []
                },
                returnType: {
                    name: ParserRule.returnType,
                    referenceType: AbstractType.$type
                }
            },
            superTypes: [AbstractParserRule.$type]
        },
        ReferenceType: {
            name: ReferenceType.$type,
            properties: {
                isMulti: {
                    name: ReferenceType.isMulti,
                    defaultValue: false
                },
                referenceType: {
                    name: ReferenceType.referenceType
                }
            },
            superTypes: [TypeDefinition.$type]
        },
        RegexToken: {
            name: RegexToken.$type,
            properties: {
                cardinality: {
                    name: RegexToken.cardinality
                },
                lookahead: {
                    name: RegexToken.lookahead
                },
                parenthesized: {
                    name: RegexToken.parenthesized,
                    defaultValue: false
                },
                regex: {
                    name: RegexToken.regex
                }
            },
            superTypes: [TerminalElement.$type]
        },
        ReturnType: {
            name: ReturnType.$type,
            properties: {
                name: {
                    name: ReturnType.name
                }
            },
            superTypes: []
        },
        RuleCall: {
            name: RuleCall.$type,
            properties: {
                arguments: {
                    name: RuleCall.arguments,
                    defaultValue: []
                },
                cardinality: {
                    name: RuleCall.cardinality
                },
                predicate: {
                    name: RuleCall.predicate
                },
                rule: {
                    name: RuleCall.rule,
                    referenceType: AbstractRule.$type
                }
            },
            superTypes: [AbstractElement.$type]
        },
        SimpleType: {
            name: SimpleType.$type,
            properties: {
                primitiveType: {
                    name: SimpleType.primitiveType
                },
                stringType: {
                    name: SimpleType.stringType
                },
                typeRef: {
                    name: SimpleType.typeRef,
                    referenceType: AbstractType.$type
                }
            },
            superTypes: [TypeDefinition.$type]
        },
        StringLiteral: {
            name: StringLiteral.$type,
            properties: {
                value: {
                    name: StringLiteral.value
                }
            },
            superTypes: [ValueLiteral.$type]
        },
        TerminalAlternatives: {
            name: TerminalAlternatives.$type,
            properties: {
                cardinality: {
                    name: TerminalAlternatives.cardinality
                },
                elements: {
                    name: TerminalAlternatives.elements,
                    defaultValue: []
                },
                lookahead: {
                    name: TerminalAlternatives.lookahead
                },
                parenthesized: {
                    name: TerminalAlternatives.parenthesized,
                    defaultValue: false
                }
            },
            superTypes: [TerminalElement.$type]
        },
        TerminalElement: {
            name: TerminalElement.$type,
            properties: {
                cardinality: {
                    name: TerminalElement.cardinality
                },
                lookahead: {
                    name: TerminalElement.lookahead
                },
                parenthesized: {
                    name: TerminalElement.parenthesized,
                    defaultValue: false
                }
            },
            superTypes: [AbstractElement.$type]
        },
        TerminalGroup: {
            name: TerminalGroup.$type,
            properties: {
                cardinality: {
                    name: TerminalGroup.cardinality
                },
                elements: {
                    name: TerminalGroup.elements,
                    defaultValue: []
                },
                lookahead: {
                    name: TerminalGroup.lookahead
                },
                parenthesized: {
                    name: TerminalGroup.parenthesized,
                    defaultValue: false
                }
            },
            superTypes: [TerminalElement.$type]
        },
        TerminalRule: {
            name: TerminalRule.$type,
            properties: {
                definition: {
                    name: TerminalRule.definition
                },
                fragment: {
                    name: TerminalRule.fragment,
                    defaultValue: false
                },
                hidden: {
                    name: TerminalRule.hidden,
                    defaultValue: false
                },
                name: {
                    name: TerminalRule.name
                },
                type: {
                    name: TerminalRule.type
                }
            },
            superTypes: [AbstractRule.$type]
        },
        TerminalRuleCall: {
            name: TerminalRuleCall.$type,
            properties: {
                cardinality: {
                    name: TerminalRuleCall.cardinality
                },
                lookahead: {
                    name: TerminalRuleCall.lookahead
                },
                parenthesized: {
                    name: TerminalRuleCall.parenthesized,
                    defaultValue: false
                },
                rule: {
                    name: TerminalRuleCall.rule,
                    referenceType: TerminalRule.$type
                }
            },
            superTypes: [TerminalElement.$type]
        },
        Type: {
            name: Type.$type,
            properties: {
                name: {
                    name: Type.name
                },
                type: {
                    name: Type.type
                }
            },
            superTypes: [AbstractType.$type]
        },
        TypeAttribute: {
            name: TypeAttribute.$type,
            properties: {
                defaultValue: {
                    name: TypeAttribute.defaultValue
                },
                isOptional: {
                    name: TypeAttribute.isOptional,
                    defaultValue: false
                },
                name: {
                    name: TypeAttribute.name
                },
                type: {
                    name: TypeAttribute.type
                }
            },
            superTypes: []
        },
        TypeDefinition: {
            name: TypeDefinition.$type,
            properties: {
            },
            superTypes: []
        },
        UnionType: {
            name: UnionType.$type,
            properties: {
                types: {
                    name: UnionType.types,
                    defaultValue: []
                }
            },
            superTypes: [TypeDefinition.$type]
        },
        UnorderedGroup: {
            name: UnorderedGroup.$type,
            properties: {
                cardinality: {
                    name: UnorderedGroup.cardinality
                },
                elements: {
                    name: UnorderedGroup.elements,
                    defaultValue: []
                }
            },
            superTypes: [AbstractElement.$type]
        },
        UntilToken: {
            name: UntilToken.$type,
            properties: {
                cardinality: {
                    name: UntilToken.cardinality
                },
                lookahead: {
                    name: UntilToken.lookahead
                },
                parenthesized: {
                    name: UntilToken.parenthesized,
                    defaultValue: false
                },
                terminal: {
                    name: UntilToken.terminal
                }
            },
            superTypes: [TerminalElement.$type]
        },
        ValueLiteral: {
            name: ValueLiteral.$type,
            properties: {
            },
            superTypes: []
        },
        Wildcard: {
            name: Wildcard.$type,
            properties: {
                cardinality: {
                    name: Wildcard.cardinality
                },
                lookahead: {
                    name: Wildcard.lookahead
                },
                parenthesized: {
                    name: Wildcard.parenthesized,
                    defaultValue: false
                }
            },
            superTypes: [TerminalElement.$type]
        }
    } as const satisfies langium.AstMetaData
}

export const reflection = new LangiumGrammarAstReflection();

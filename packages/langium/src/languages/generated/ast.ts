/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from '../../syntax-tree.js';

export const LangiumGrammarTerminals = {
    ID: /\^?[_a-zA-Z][\w_]*/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    NUMBER: /NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity)/,
    RegexLiteral: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\/[a-z]*/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type LangiumGrammarTerminalNames = keyof typeof LangiumGrammarTerminals;

export type LangiumGrammarKeywordNames =
    | "!"
    | "&"
    | "("
    | ")"
    | "*"
    | "+"
    | "+="
    | ","
    | "->"
    | "."
    | ".."
    | ":"
    | ";"
    | "<"
    | "="
    | "=>"
    | ">"
    | "?"
    | "?!"
    | "?<!"
    | "?<="
    | "?="
    | "@"
    | "Date"
    | "EOF"
    | "["
    | "]"
    | "bigint"
    | "boolean"
    | "current"
    | "entry"
    | "extends"
    | "false"
    | "fragment"
    | "grammar"
    | "hidden"
    | "import"
    | "infer"
    | "infers"
    | "interface"
    | "number"
    | "returns"
    | "string"
    | "terminal"
    | "true"
    | "type"
    | "with"
    | "{"
    | "|"
    | "}";

export type LangiumGrammarTokenNames = LangiumGrammarTerminalNames | LangiumGrammarKeywordNames;

export type AbstractRule = ParserRule | TerminalRule;

export const AbstractRule = 'AbstractRule';

export function isAbstractRule(item: unknown): item is AbstractRule {
    return reflection.isInstance(item, AbstractRule);
}

export type AbstractType = InferredType | Interface | ParserRule | Type;

export const AbstractType = 'AbstractType';

export function isAbstractType(item: unknown): item is AbstractType {
    return reflection.isInstance(item, AbstractType);
}

export type C = A | B;

export const C = 'C';

export function isC(item: unknown): item is C {
    return reflection.isInstance(item, C);
}

export type Condition = BooleanLiteral | Conjunction | Disjunction | Negation | ParameterReference;

export const Condition = 'Condition';

export function isCondition(item: unknown): item is Condition {
    return reflection.isInstance(item, Condition);
}

export type FeatureName = 'current' | 'entry' | 'extends' | 'false' | 'fragment' | 'grammar' | 'hidden' | 'import' | 'infer' | 'infers' | 'interface' | 'returns' | 'terminal' | 'true' | 'type' | 'with' | PrimitiveType | string;

export function isFeatureName(item: unknown): item is FeatureName {
    return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\^?[_a-zA-Z][\w_]*/.test(item)));
}

export type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';

export function isPrimitiveType(item: unknown): item is PrimitiveType {
    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';
}

export type TypeDefinition = ArrayType | ReferenceType | SimpleType | UnionType;

export const TypeDefinition = 'TypeDefinition';

export function isTypeDefinition(item: unknown): item is TypeDefinition {
    return reflection.isInstance(item, TypeDefinition);
}

export type ValueLiteral = ArrayLiteral | BooleanLiteral | NumberLiteral | StringLiteral;

export const ValueLiteral = 'ValueLiteral';

export function isValueLiteral(item: unknown): item is ValueLiteral {
    return reflection.isInstance(item, ValueLiteral);
}

export interface A extends langium.AstNode {
    readonly $type: 'A';
    a: string;
    joint: string;
}

export const A = 'A';

export function isA(item: unknown): item is A {
    return reflection.isInstance(item, A);
}

export interface AbstractElement extends langium.AstNode {
    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'EndOfFile' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';
    cardinality?: '*' | '+' | '?';
    lookahead?: '?!' | '?<!' | '?<=' | '?=';
}

export const AbstractElement = 'AbstractElement';

export function isAbstractElement(item: unknown): item is AbstractElement {
    return reflection.isInstance(item, AbstractElement);
}

export interface ArrayLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'ArrayLiteral';
    elements: Array<ValueLiteral>;
}

export const ArrayLiteral = 'ArrayLiteral';

export function isArrayLiteral(item: unknown): item is ArrayLiteral {
    return reflection.isInstance(item, ArrayLiteral);
}

export interface ArrayType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ArrayType';
    elementType: TypeDefinition;
}

export const ArrayType = 'ArrayType';

export function isArrayType(item: unknown): item is ArrayType {
    return reflection.isInstance(item, ArrayType);
}

export interface B extends langium.AstNode {
    readonly $type: 'B';
    b: string;
    joint: string;
}

export const B = 'B';

export function isB(item: unknown): item is B {
    return reflection.isInstance(item, B);
}

export interface BooleanLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | Conjunction | Disjunction | Group | NamedArgument | Negation | TypeAttribute;
    readonly $type: 'BooleanLiteral';
    true: boolean;
}

export const BooleanLiteral = 'BooleanLiteral';

export function isBooleanLiteral(item: unknown): item is BooleanLiteral {
    return reflection.isInstance(item, BooleanLiteral);
}

export interface Conjunction extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Conjunction';
    left: Condition;
    right: Condition;
}

export const Conjunction = 'Conjunction';

export function isConjunction(item: unknown): item is Conjunction {
    return reflection.isInstance(item, Conjunction);
}

export interface Disjunction extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Disjunction';
    left: Condition;
    right: Condition;
}

export const Disjunction = 'Disjunction';

export function isDisjunction(item: unknown): item is Disjunction {
    return reflection.isInstance(item, Disjunction);
}

export interface Grammar extends langium.AstNode {
    readonly $type: 'Grammar';
    definesHiddenTokens: boolean;
    hiddenTokens: Array<langium.Reference<AbstractRule>>;
    imports: Array<GrammarImport>;
    interfaces: Array<Interface>;
    isDeclared: boolean;
    name?: string;
    rules: Array<AbstractRule>;
    types: Array<Type>;
    usedGrammars: Array<langium.Reference<Grammar>>;
}

export const Grammar = 'Grammar';

export function isGrammar(item: unknown): item is Grammar {
    return reflection.isInstance(item, Grammar);
}

export interface GrammarImport extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'GrammarImport';
    path: string;
}

export const GrammarImport = 'GrammarImport';

export function isGrammarImport(item: unknown): item is GrammarImport {
    return reflection.isInstance(item, GrammarImport);
}

export interface InferredType extends langium.AstNode {
    readonly $container: Action | ParserRule;
    readonly $type: 'InferredType';
    name: string;
}

export const InferredType = 'InferredType';

export function isInferredType(item: unknown): item is InferredType {
    return reflection.isInstance(item, InferredType);
}

export interface Interface extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'Interface';
    attributes: Array<TypeAttribute>;
    name: string;
    superTypes: Array<langium.Reference<AbstractType>>;
}

export const Interface = 'Interface';

export function isInterface(item: unknown): item is Interface {
    return reflection.isInstance(item, Interface);
}

export interface NamedArgument extends langium.AstNode {
    readonly $container: RuleCall;
    readonly $type: 'NamedArgument';
    calledByName: boolean;
    parameter?: langium.Reference<Parameter>;
    value: Condition;
}

export const NamedArgument = 'NamedArgument';

export function isNamedArgument(item: unknown): item is NamedArgument {
    return reflection.isInstance(item, NamedArgument);
}

export interface Negation extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Negation';
    value: Condition;
}

export const Negation = 'Negation';

export function isNegation(item: unknown): item is Negation {
    return reflection.isInstance(item, Negation);
}

export interface NumberLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'NumberLiteral';
    value: number;
}

export const NumberLiteral = 'NumberLiteral';

export function isNumberLiteral(item: unknown): item is NumberLiteral {
    return reflection.isInstance(item, NumberLiteral);
}

export interface Parameter extends langium.AstNode {
    readonly $container: ParserRule;
    readonly $type: 'Parameter';
    name: string;
}

export const Parameter = 'Parameter';

export function isParameter(item: unknown): item is Parameter {
    return reflection.isInstance(item, Parameter);
}

export interface ParameterReference extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'ParameterReference';
    parameter: langium.Reference<Parameter>;
}

export const ParameterReference = 'ParameterReference';

export function isParameterReference(item: unknown): item is ParameterReference {
    return reflection.isInstance(item, ParameterReference);
}

export interface ParserRule extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'ParserRule';
    dataType?: PrimitiveType;
    definesHiddenTokens: boolean;
    definition: AbstractElement;
    entry: boolean;
    fragment: boolean;
    hiddenTokens: Array<langium.Reference<AbstractRule>>;
    inferredType?: InferredType;
    name: string;
    parameters: Array<Parameter>;
    returnType?: langium.Reference<AbstractType>;
    wildcard: boolean;
}

export const ParserRule = 'ParserRule';

export function isParserRule(item: unknown): item is ParserRule {
    return reflection.isInstance(item, ParserRule);
}

export interface ReferenceType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ReferenceType';
    referenceType: TypeDefinition;
}

export const ReferenceType = 'ReferenceType';

export function isReferenceType(item: unknown): item is ReferenceType {
    return reflection.isInstance(item, ReferenceType);
}

export interface ReturnType extends langium.AstNode {
    readonly $container: TerminalRule;
    readonly $type: 'ReturnType';
    name: PrimitiveType | string;
}

export const ReturnType = 'ReturnType';

export function isReturnType(item: unknown): item is ReturnType {
    return reflection.isInstance(item, ReturnType);
}

export interface SimpleType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'SimpleType';
    primitiveType?: PrimitiveType;
    stringType?: string;
    typeRef?: langium.Reference<AbstractType>;
}

export const SimpleType = 'SimpleType';

export function isSimpleType(item: unknown): item is SimpleType {
    return reflection.isInstance(item, SimpleType);
}

export interface StringLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'StringLiteral';
    value: string;
}

export const StringLiteral = 'StringLiteral';

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, StringLiteral);
}

export interface TerminalRule extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'TerminalRule';
    definition: AbstractElement;
    fragment: boolean;
    hidden: boolean;
    name: string;
    type?: ReturnType;
}

export const TerminalRule = 'TerminalRule';

export function isTerminalRule(item: unknown): item is TerminalRule {
    return reflection.isInstance(item, TerminalRule);
}

export interface Type extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'Type';
    name: string;
    type: TypeDefinition;
}

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export interface TypeAttribute extends langium.AstNode {
    readonly $container: Interface;
    readonly $type: 'TypeAttribute';
    defaultValue?: ValueLiteral;
    isOptional: boolean;
    name: FeatureName;
    type: TypeDefinition;
}

export const TypeAttribute = 'TypeAttribute';

export function isTypeAttribute(item: unknown): item is TypeAttribute {
    return reflection.isInstance(item, TypeAttribute);
}

export interface UnionType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'UnionType';
    types: Array<TypeDefinition>;
}

export const UnionType = 'UnionType';

export function isUnionType(item: unknown): item is UnionType {
    return reflection.isInstance(item, UnionType);
}

export interface Action extends AbstractElement {
    readonly $type: 'Action';
    feature?: FeatureName;
    inferredType?: InferredType;
    operator?: '+=' | '=';
    type?: langium.Reference<AbstractType>;
}

export const Action = 'Action';

export function isAction(item: unknown): item is Action {
    return reflection.isInstance(item, Action);
}

export interface Alternatives extends AbstractElement {
    readonly $type: 'Alternatives';
    elements: Array<AbstractElement>;
}

export const Alternatives = 'Alternatives';

export function isAlternatives(item: unknown): item is Alternatives {
    return reflection.isInstance(item, Alternatives);
}

export interface Assignment extends AbstractElement {
    readonly $type: 'Assignment';
    feature: FeatureName;
    operator: '+=' | '=' | '?=';
    terminal: AbstractElement;
}

export const Assignment = 'Assignment';

export function isAssignment(item: unknown): item is Assignment {
    return reflection.isInstance(item, Assignment);
}

export interface CharacterRange extends AbstractElement {
    readonly $type: 'CharacterRange';
    left: Keyword;
    right?: Keyword;
}

export const CharacterRange = 'CharacterRange';

export function isCharacterRange(item: unknown): item is CharacterRange {
    return reflection.isInstance(item, CharacterRange);
}

export interface CrossReference extends AbstractElement {
    readonly $type: 'CrossReference';
    deprecatedSyntax: boolean;
    terminal?: AbstractElement;
    type: langium.Reference<AbstractType>;
}

export const CrossReference = 'CrossReference';

export function isCrossReference(item: unknown): item is CrossReference {
    return reflection.isInstance(item, CrossReference);
}

export interface EndOfFile extends AbstractElement {
    readonly $type: 'EndOfFile';
}

export const EndOfFile = 'EndOfFile';

export function isEndOfFile(item: unknown): item is EndOfFile {
    return reflection.isInstance(item, EndOfFile);
}

export interface Group extends AbstractElement {
    readonly $type: 'Group';
    elements: Array<AbstractElement>;
    guardCondition?: Condition;
}

export const Group = 'Group';

export function isGroup(item: unknown): item is Group {
    return reflection.isInstance(item, Group);
}

export interface Keyword extends AbstractElement {
    readonly $container: CharacterRange;
    readonly $type: 'Keyword';
    value: string;
}

export const Keyword = 'Keyword';

export function isKeyword(item: unknown): item is Keyword {
    return reflection.isInstance(item, Keyword);
}

export interface NegatedToken extends AbstractElement {
    readonly $type: 'NegatedToken';
    terminal: AbstractElement;
}

export const NegatedToken = 'NegatedToken';

export function isNegatedToken(item: unknown): item is NegatedToken {
    return reflection.isInstance(item, NegatedToken);
}

export interface RegexToken extends AbstractElement {
    readonly $type: 'RegexToken';
    regex: string;
}

export const RegexToken = 'RegexToken';

export function isRegexToken(item: unknown): item is RegexToken {
    return reflection.isInstance(item, RegexToken);
}

export interface RuleCall extends AbstractElement {
    readonly $type: 'RuleCall';
    arguments: Array<NamedArgument>;
    rule: langium.Reference<AbstractRule>;
}

export const RuleCall = 'RuleCall';

export function isRuleCall(item: unknown): item is RuleCall {
    return reflection.isInstance(item, RuleCall);
}

export interface TerminalAlternatives extends AbstractElement {
    readonly $type: 'TerminalAlternatives';
    elements: Array<AbstractElement>;
}

export const TerminalAlternatives = 'TerminalAlternatives';

export function isTerminalAlternatives(item: unknown): item is TerminalAlternatives {
    return reflection.isInstance(item, TerminalAlternatives);
}

export interface TerminalGroup extends AbstractElement {
    readonly $type: 'TerminalGroup';
    elements: Array<AbstractElement>;
}

export const TerminalGroup = 'TerminalGroup';

export function isTerminalGroup(item: unknown): item is TerminalGroup {
    return reflection.isInstance(item, TerminalGroup);
}

export interface TerminalRuleCall extends AbstractElement {
    readonly $type: 'TerminalRuleCall';
    rule: langium.Reference<TerminalRule>;
}

export const TerminalRuleCall = 'TerminalRuleCall';

export function isTerminalRuleCall(item: unknown): item is TerminalRuleCall {
    return reflection.isInstance(item, TerminalRuleCall);
}

export interface UnorderedGroup extends AbstractElement {
    readonly $type: 'UnorderedGroup';
    elements: Array<AbstractElement>;
}

export const UnorderedGroup = 'UnorderedGroup';

export function isUnorderedGroup(item: unknown): item is UnorderedGroup {
    return reflection.isInstance(item, UnorderedGroup);
}

export interface UntilToken extends AbstractElement {
    readonly $type: 'UntilToken';
    terminal: AbstractElement;
}

export const UntilToken = 'UntilToken';

export function isUntilToken(item: unknown): item is UntilToken {
    return reflection.isInstance(item, UntilToken);
}

export interface Wildcard extends AbstractElement {
    readonly $type: 'Wildcard';
}

export const Wildcard = 'Wildcard';

export function isWildcard(item: unknown): item is Wildcard {
    return reflection.isInstance(item, Wildcard);
}

export type LangiumGrammarAstType = {
    A: A
    AbstractElement: AbstractElement
    AbstractRule: AbstractRule
    AbstractType: AbstractType
    Action: Action
    Alternatives: Alternatives
    ArrayLiteral: ArrayLiteral
    ArrayType: ArrayType
    Assignment: Assignment
    B: B
    BooleanLiteral: BooleanLiteral
    C: C
    CharacterRange: CharacterRange
    Condition: Condition
    Conjunction: Conjunction
    CrossReference: CrossReference
    Disjunction: Disjunction
    EndOfFile: EndOfFile
    Grammar: Grammar
    GrammarImport: GrammarImport
    Group: Group
    InferredType: InferredType
    Interface: Interface
    Keyword: Keyword
    NamedArgument: NamedArgument
    NegatedToken: NegatedToken
    Negation: Negation
    NumberLiteral: NumberLiteral
    Parameter: Parameter
    ParameterReference: ParameterReference
    ParserRule: ParserRule
    ReferenceType: ReferenceType
    RegexToken: RegexToken
    ReturnType: ReturnType
    RuleCall: RuleCall
    SimpleType: SimpleType
    StringLiteral: StringLiteral
    TerminalAlternatives: TerminalAlternatives
    TerminalGroup: TerminalGroup
    TerminalRule: TerminalRule
    TerminalRuleCall: TerminalRuleCall
    Type: Type
    TypeAttribute: TypeAttribute
    TypeDefinition: TypeDefinition
    UnionType: UnionType
    UnorderedGroup: UnorderedGroup
    UntilToken: UntilToken
    ValueLiteral: ValueLiteral
    Wildcard: Wildcard
}

export const properties: langium.AstTypeProperties<LangiumGrammarAstType> = langium.deepFreeze({
    A: {
        $name: A,
        a: 'a',
        joint: 'joint',
    },
    AbstractElement: {
        $name: AbstractElement,
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    AbstractRule: {
        $name: AbstractRule,
        dataType: 'dataType',
        definesHiddenTokens: 'definesHiddenTokens',
        definition: 'definition',
        entry: 'entry',
        fragment: 'fragment',
        hiddenTokens: 'hiddenTokens',
        inferredType: 'inferredType',
        name: 'name',
        parameters: 'parameters',
        returnType: 'returnType',
        wildcard: 'wildcard',
    },
    AbstractType: {
        $name: AbstractType,
        attributes: 'attributes',
        name: 'name',
        superTypes: 'superTypes',
    },
    Action: {
        $name: Action,
        feature: 'feature',
        inferredType: 'inferredType',
        operator: 'operator',
        type: 'type',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    Alternatives: {
        $name: Alternatives,
        elements: 'elements',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    ArrayLiteral: {
        $name: ArrayLiteral,
        elements: 'elements',
    },
    ArrayType: {
        $name: ArrayType,
        elementType: 'elementType',
    },
    Assignment: {
        $name: Assignment,
        feature: 'feature',
        operator: 'operator',
        terminal: 'terminal',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    B: {
        $name: B,
        b: 'b',
        joint: 'joint',
    },
    BooleanLiteral: {
        $name: BooleanLiteral,
        true: 'true',
    },
    C: {
        $name: C,
        a: 'a',
        joint: 'joint',
    },
    CharacterRange: {
        $name: CharacterRange,
        left: 'left',
        right: 'right',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    Condition: {
        $name: Condition,
        true: 'true',
    },
    Conjunction: {
        $name: Conjunction,
        left: 'left',
        right: 'right',
    },
    CrossReference: {
        $name: CrossReference,
        deprecatedSyntax: 'deprecatedSyntax',
        terminal: 'terminal',
        type: 'type',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    Disjunction: {
        $name: Disjunction,
        left: 'left',
        right: 'right',
    },
    EndOfFile: {
        $name: EndOfFile,
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    Grammar: {
        $name: Grammar,
        definesHiddenTokens: 'definesHiddenTokens',
        hiddenTokens: 'hiddenTokens',
        imports: 'imports',
        interfaces: 'interfaces',
        isDeclared: 'isDeclared',
        name: 'name',
        rules: 'rules',
        types: 'types',
        usedGrammars: 'usedGrammars',
    },
    GrammarImport: {
        $name: GrammarImport,
        path: 'path',
    },
    Group: {
        $name: Group,
        elements: 'elements',
        guardCondition: 'guardCondition',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    InferredType: {
        $name: InferredType,
        name: 'name',
    },
    Interface: {
        $name: Interface,
        attributes: 'attributes',
        name: 'name',
        superTypes: 'superTypes',
    },
    Keyword: {
        $name: Keyword,
        value: 'value',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    NamedArgument: {
        $name: NamedArgument,
        calledByName: 'calledByName',
        parameter: 'parameter',
        value: 'value',
    },
    NegatedToken: {
        $name: NegatedToken,
        terminal: 'terminal',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    Negation: {
        $name: Negation,
        value: 'value',
    },
    NumberLiteral: {
        $name: NumberLiteral,
        value: 'value',
    },
    Parameter: {
        $name: Parameter,
        name: 'name',
    },
    ParameterReference: {
        $name: ParameterReference,
        parameter: 'parameter',
    },
    ParserRule: {
        $name: ParserRule,
        dataType: 'dataType',
        definesHiddenTokens: 'definesHiddenTokens',
        definition: 'definition',
        entry: 'entry',
        fragment: 'fragment',
        hiddenTokens: 'hiddenTokens',
        inferredType: 'inferredType',
        name: 'name',
        parameters: 'parameters',
        returnType: 'returnType',
        wildcard: 'wildcard',
    },
    ReferenceType: {
        $name: ReferenceType,
        referenceType: 'referenceType',
    },
    RegexToken: {
        $name: RegexToken,
        regex: 'regex',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    ReturnType: {
        $name: ReturnType,
        name: 'name',
    },
    RuleCall: {
        $name: RuleCall,
        arguments: 'arguments',
        rule: 'rule',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    SimpleType: {
        $name: SimpleType,
        primitiveType: 'primitiveType',
        stringType: 'stringType',
        typeRef: 'typeRef',
    },
    StringLiteral: {
        $name: StringLiteral,
        value: 'value',
    },
    TerminalAlternatives: {
        $name: TerminalAlternatives,
        elements: 'elements',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    TerminalGroup: {
        $name: TerminalGroup,
        elements: 'elements',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    TerminalRule: {
        $name: TerminalRule,
        definition: 'definition',
        fragment: 'fragment',
        hidden: 'hidden',
        name: 'name',
        type: 'type',
    },
    TerminalRuleCall: {
        $name: TerminalRuleCall,
        rule: 'rule',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    Type: {
        $name: Type,
        name: 'name',
        type: 'type',
    },
    TypeAttribute: {
        $name: TypeAttribute,
        defaultValue: 'defaultValue',
        isOptional: 'isOptional',
        name: 'name',
        type: 'type',
    },
    TypeDefinition: {
        $name: TypeDefinition,
        types: 'types',
    },
    UnionType: {
        $name: UnionType,
        types: 'types',
    },
    UnorderedGroup: {
        $name: UnorderedGroup,
        elements: 'elements',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    UntilToken: {
        $name: UntilToken,
        terminal: 'terminal',
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
    ValueLiteral: {
        $name: ValueLiteral,
        value: 'value',
    },
    Wildcard: {
        $name: Wildcard,
        cardinality: 'cardinality',
        lookahead: 'lookahead',
    },
});

export class LangiumGrammarAstReflection extends langium.AbstractAstReflection {

    readonly A = {
        $name: A,
        $properties: {
            a: { name: 'a', type: 'string', kind: 'Primitive' },
            joint: { name: 'joint', type: 'string', kind: 'Primitive' },
        },
    };
    readonly AbstractElement = {
        $name: AbstractElement,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
        },
    };
    readonly AbstractRule = {
        $name: AbstractRule,
        $properties: {
            dataType: { name: 'dataType', type: 'PrimitiveType', kind: 'Primitive' },
            definesHiddenTokens: { name: 'definesHiddenTokens', type: 'boolean', kind: 'Primitive', defaultValue: false },
            definition: { name: 'definition', type: 'AbstractElement', kind: 'Containment' },
            entry: { name: 'entry', type: 'boolean', kind: 'Primitive', defaultValue: false },
            fragment: { name: 'fragment', type: 'boolean', kind: 'Primitive', defaultValue: false },
            hiddenTokens: { name: 'hiddenTokens', type: 'AbstractRule', kind: 'Reference', defaultValue: [] },
            inferredType: { name: 'inferredType', type: 'InferredType', kind: 'Containment' },
            name: { name: 'name', type: 'string', kind: 'Primitive' },
            parameters: { name: 'parameters', type: 'Parameter', kind: 'Containment', defaultValue: [] },
            returnType: { name: 'returnType', type: 'AbstractType', kind: 'Reference' },
            wildcard: { name: 'wildcard', type: 'boolean', kind: 'Primitive', defaultValue: false },
        },
    };
    readonly AbstractType = {
        $name: AbstractType,
        $properties: {
            attributes: { name: 'attributes', type: 'TypeAttribute', kind: 'Containment', defaultValue: [] },
            name: { name: 'name', type: 'string', kind: 'Primitive' },
            superTypes: { name: 'superTypes', type: 'AbstractType', kind: 'Reference', defaultValue: [] },
        },
    };
    readonly Action = {
        $name: Action,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            feature: { name: 'feature', type: 'FeatureName', kind: 'Primitive' },
            inferredType: { name: 'inferredType', type: 'InferredType', kind: 'Containment' },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
            operator: { name: 'operator', type: '"+=" | "="', kind: 'Primitive' },
            type: { name: 'type', type: 'AbstractType', kind: 'Reference' },
        },
    };
    readonly Alternatives = {
        $name: Alternatives,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            elements: { name: 'elements', type: 'AbstractElement', kind: 'Containment', defaultValue: [] },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
        },
    };
    readonly ArrayLiteral = {
        $name: ArrayLiteral,
        $properties: {
            elements: { name: 'elements', type: 'ValueLiteral', kind: 'Containment', defaultValue: [] },
        },
    };
    readonly ArrayType = {
        $name: ArrayType,
        $properties: {
            elementType: { name: 'elementType', type: 'TypeDefinition', kind: 'Containment' },
        },
    };
    readonly Assignment = {
        $name: Assignment,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            feature: { name: 'feature', type: 'FeatureName', kind: 'Primitive' },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
            operator: { name: 'operator', type: '"+=" | "=" | "?="', kind: 'Primitive' },
            terminal: { name: 'terminal', type: 'AbstractElement', kind: 'Containment' },
        },
    };
    readonly B = {
        $name: B,
        $properties: {
            b: { name: 'b', type: 'string', kind: 'Primitive' },
            joint: { name: 'joint', type: 'string', kind: 'Primitive' },
        },
    };
    readonly BooleanLiteral = {
        $name: BooleanLiteral,
        $properties: {
            true: { name: 'true', type: 'boolean', kind: 'Primitive', defaultValue: false },
        },
    };
    readonly C = {
        $name: C,
        $properties: {
            a: { name: 'a', type: 'string', kind: 'Primitive' },
            joint: { name: 'joint', type: 'string', kind: 'Primitive' },
        },
    };
    readonly CharacterRange = {
        $name: CharacterRange,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            left: { name: 'left', type: 'Keyword', kind: 'Containment' },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
            right: { name: 'right', type: 'Keyword', kind: 'Containment' },
        },
    };
    readonly Condition = {
        $name: Condition,
        $properties: {
            true: { name: 'true', type: 'boolean', kind: 'Primitive', defaultValue: false },
        },
    };
    readonly Conjunction = {
        $name: Conjunction,
        $properties: {
            left: { name: 'left', type: 'Condition', kind: 'Containment' },
            right: { name: 'right', type: 'Condition', kind: 'Containment' },
        },
    };
    readonly CrossReference = {
        $name: CrossReference,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            deprecatedSyntax: { name: 'deprecatedSyntax', type: 'boolean', kind: 'Primitive', defaultValue: false },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
            terminal: { name: 'terminal', type: 'AbstractElement', kind: 'Containment' },
            type: { name: 'type', type: 'AbstractType', kind: 'Reference' },
        },
    };
    readonly Disjunction = {
        $name: Disjunction,
        $properties: {
            left: { name: 'left', type: 'Condition', kind: 'Containment' },
            right: { name: 'right', type: 'Condition', kind: 'Containment' },
        },
    };
    readonly EndOfFile = {
        $name: EndOfFile,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
        },
    };
    readonly Grammar = {
        $name: Grammar,
        $properties: {
            definesHiddenTokens: { name: 'definesHiddenTokens', type: 'boolean', kind: 'Primitive', defaultValue: false },
            hiddenTokens: { name: 'hiddenTokens', type: 'AbstractRule', kind: 'Reference', defaultValue: [] },
            imports: { name: 'imports', type: 'GrammarImport', kind: 'Containment', defaultValue: [] },
            interfaces: { name: 'interfaces', type: 'Interface', kind: 'Containment', defaultValue: [] },
            isDeclared: { name: 'isDeclared', type: 'boolean', kind: 'Primitive', defaultValue: false },
            name: { name: 'name', type: 'string', kind: 'Primitive' },
            rules: { name: 'rules', type: 'AbstractRule', kind: 'Containment', defaultValue: [] },
            types: { name: 'types', type: 'Type', kind: 'Containment', defaultValue: [] },
            usedGrammars: { name: 'usedGrammars', type: 'Grammar', kind: 'Reference', defaultValue: [] },
        },
    };
    readonly GrammarImport = {
        $name: GrammarImport,
        $properties: {
            path: { name: 'path', type: 'string', kind: 'Primitive' },
        },
    };
    readonly Group = {
        $name: Group,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            elements: { name: 'elements', type: 'AbstractElement', kind: 'Containment', defaultValue: [] },
            guardCondition: { name: 'guardCondition', type: 'Condition', kind: 'Containment' },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
        },
    };
    readonly InferredType = {
        $name: InferredType,
        $properties: {
            name: { name: 'name', type: 'string', kind: 'Primitive' },
        },
    };
    readonly Interface = {
        $name: Interface,
        $properties: {
            attributes: { name: 'attributes', type: 'TypeAttribute', kind: 'Containment', defaultValue: [] },
            name: { name: 'name', type: 'string', kind: 'Primitive' },
            superTypes: { name: 'superTypes', type: 'AbstractType', kind: 'Reference', defaultValue: [] },
        },
    };
    readonly Keyword = {
        $name: Keyword,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
            value: { name: 'value', type: 'string', kind: 'Primitive' },
        },
    };
    readonly NamedArgument = {
        $name: NamedArgument,
        $properties: {
            calledByName: { name: 'calledByName', type: 'boolean', kind: 'Primitive', defaultValue: false },
            parameter: { name: 'parameter', type: 'Parameter', kind: 'Reference' },
            value: { name: 'value', type: 'Condition', kind: 'Containment' },
        },
    };
    readonly NegatedToken = {
        $name: NegatedToken,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
            terminal: { name: 'terminal', type: 'AbstractElement', kind: 'Containment' },
        },
    };
    readonly Negation = {
        $name: Negation,
        $properties: {
            value: { name: 'value', type: 'Condition', kind: 'Containment' },
        },
    };
    readonly NumberLiteral = {
        $name: NumberLiteral,
        $properties: {
            value: { name: 'value', type: 'number', kind: 'Primitive' },
        },
    };
    readonly Parameter = {
        $name: Parameter,
        $properties: {
            name: { name: 'name', type: 'string', kind: 'Primitive' },
        },
    };
    readonly ParameterReference = {
        $name: ParameterReference,
        $properties: {
            parameter: { name: 'parameter', type: 'Parameter', kind: 'Reference' },
        },
    };
    readonly ParserRule = {
        $name: ParserRule,
        $properties: {
            dataType: { name: 'dataType', type: 'PrimitiveType', kind: 'Primitive' },
            definesHiddenTokens: { name: 'definesHiddenTokens', type: 'boolean', kind: 'Primitive', defaultValue: false },
            definition: { name: 'definition', type: 'AbstractElement', kind: 'Containment' },
            entry: { name: 'entry', type: 'boolean', kind: 'Primitive', defaultValue: false },
            fragment: { name: 'fragment', type: 'boolean', kind: 'Primitive', defaultValue: false },
            hiddenTokens: { name: 'hiddenTokens', type: 'AbstractRule', kind: 'Reference', defaultValue: [] },
            inferredType: { name: 'inferredType', type: 'InferredType', kind: 'Containment' },
            name: { name: 'name', type: 'string', kind: 'Primitive' },
            parameters: { name: 'parameters', type: 'Parameter', kind: 'Containment', defaultValue: [] },
            returnType: { name: 'returnType', type: 'AbstractType', kind: 'Reference' },
            wildcard: { name: 'wildcard', type: 'boolean', kind: 'Primitive', defaultValue: false },
        },
    };
    readonly ReferenceType = {
        $name: ReferenceType,
        $properties: {
            referenceType: { name: 'referenceType', type: 'TypeDefinition', kind: 'Containment' },
        },
    };
    readonly RegexToken = {
        $name: RegexToken,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
            regex: { name: 'regex', type: 'string', kind: 'Primitive' },
        },
    };
    readonly ReturnType = {
        $name: ReturnType,
        $properties: {
            name: { name: 'name', type: 'PrimitiveType | string', kind: 'Primitive' },
        },
    };
    readonly RuleCall = {
        $name: RuleCall,
        $properties: {
            arguments: { name: 'arguments', type: 'NamedArgument', kind: 'Containment', defaultValue: [] },
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
            rule: { name: 'rule', type: 'AbstractRule', kind: 'Reference' },
        },
    };
    readonly SimpleType = {
        $name: SimpleType,
        $properties: {
            primitiveType: { name: 'primitiveType', type: 'PrimitiveType', kind: 'Primitive' },
            stringType: { name: 'stringType', type: 'string', kind: 'Primitive' },
            typeRef: { name: 'typeRef', type: 'AbstractType', kind: 'Reference' },
        },
    };
    readonly StringLiteral = {
        $name: StringLiteral,
        $properties: {
            value: { name: 'value', type: 'string', kind: 'Primitive' },
        },
    };
    readonly TerminalAlternatives = {
        $name: TerminalAlternatives,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            elements: { name: 'elements', type: 'AbstractElement', kind: 'Containment', defaultValue: [] },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
        },
    };
    readonly TerminalGroup = {
        $name: TerminalGroup,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            elements: { name: 'elements', type: 'AbstractElement', kind: 'Containment', defaultValue: [] },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
        },
    };
    readonly TerminalRule = {
        $name: TerminalRule,
        $properties: {
            definition: { name: 'definition', type: 'AbstractElement', kind: 'Containment' },
            fragment: { name: 'fragment', type: 'boolean', kind: 'Primitive', defaultValue: false },
            hidden: { name: 'hidden', type: 'boolean', kind: 'Primitive', defaultValue: false },
            name: { name: 'name', type: 'string', kind: 'Primitive' },
            type: { name: 'type', type: 'ReturnType', kind: 'Containment' },
        },
    };
    readonly TerminalRuleCall = {
        $name: TerminalRuleCall,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
            rule: { name: 'rule', type: 'TerminalRule', kind: 'Reference' },
        },
    };
    readonly Type = {
        $name: Type,
        $properties: {
            name: { name: 'name', type: 'string', kind: 'Primitive' },
            type: { name: 'type', type: 'TypeDefinition', kind: 'Containment' },
        },
    };
    readonly TypeAttribute = {
        $name: TypeAttribute,
        $properties: {
            defaultValue: { name: 'defaultValue', type: 'ValueLiteral', kind: 'Containment' },
            isOptional: { name: 'isOptional', type: 'boolean', kind: 'Primitive', defaultValue: false },
            name: { name: 'name', type: 'FeatureName', kind: 'Primitive' },
            type: { name: 'type', type: 'TypeDefinition', kind: 'Containment' },
        },
    };
    readonly TypeDefinition = {
        $name: TypeDefinition,
        $properties: {
            types: { name: 'types', type: 'TypeDefinition', kind: 'Containment', defaultValue: [] },
        },
    };
    readonly UnionType = {
        $name: UnionType,
        $properties: {
            types: { name: 'types', type: 'TypeDefinition', kind: 'Containment', defaultValue: [] },
        },
    };
    readonly UnorderedGroup = {
        $name: UnorderedGroup,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            elements: { name: 'elements', type: 'AbstractElement', kind: 'Containment', defaultValue: [] },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
        },
    };
    readonly UntilToken = {
        $name: UntilToken,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
            terminal: { name: 'terminal', type: 'AbstractElement', kind: 'Containment' },
        },
    };
    readonly ValueLiteral = {
        $name: ValueLiteral,
        $properties: {
            value: { name: 'value', type: 'string', kind: 'Primitive' },
        },
    };
    readonly Wildcard = {
        $name: Wildcard,
        $properties: {
            cardinality: { name: 'cardinality', type: '"*" | "+" | "?"', kind: 'Primitive' },
            lookahead: { name: 'lookahead', type: '"?!" | "?<!" | "?<=" | "?="', kind: 'Primitive' },
        },
    };

    getAllTypes(): string[] {
        return [A, AbstractElement, AbstractRule, AbstractType, Action, Alternatives, ArrayLiteral, ArrayType, Assignment, B, BooleanLiteral, C, CharacterRange, Condition, Conjunction, CrossReference, Disjunction, EndOfFile, Grammar, GrammarImport, Group, InferredType, Interface, Keyword, NamedArgument, NegatedToken, Negation, NumberLiteral, Parameter, ParameterReference, ParserRule, ReferenceType, RegexToken, ReturnType, RuleCall, SimpleType, StringLiteral, TerminalAlternatives, TerminalGroup, TerminalRule, TerminalRuleCall, Type, TypeAttribute, TypeDefinition, UnionType, UnorderedGroup, UntilToken, ValueLiteral, Wildcard];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case A:
            case B: {
                return this.isSubtype(C, supertype);
            }
            case Action:
            case Alternatives:
            case Assignment:
            case CharacterRange:
            case CrossReference:
            case EndOfFile:
            case Group:
            case Keyword:
            case NegatedToken:
            case RegexToken:
            case RuleCall:
            case TerminalAlternatives:
            case TerminalGroup:
            case TerminalRuleCall:
            case UnorderedGroup:
            case UntilToken:
            case Wildcard: {
                return this.isSubtype(AbstractElement, supertype);
            }
            case ArrayLiteral:
            case NumberLiteral:
            case StringLiteral: {
                return this.isSubtype(ValueLiteral, supertype);
            }
            case ArrayType:
            case ReferenceType:
            case SimpleType:
            case UnionType: {
                return this.isSubtype(TypeDefinition, supertype);
            }
            case BooleanLiteral: {
                return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);
            }
            case Conjunction:
            case Disjunction:
            case Negation:
            case ParameterReference: {
                return this.isSubtype(Condition, supertype);
            }
            case InferredType:
            case Interface:
            case Type: {
                return this.isSubtype(AbstractType, supertype);
            }
            case ParserRule: {
                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);
            }
            case TerminalRule: {
                return this.isSubtype(AbstractRule, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: langium.ReferenceInfo): string {
        // TODO move both methods into the parent class?
        const containerTypeName = refInfo.container.$type;
        const containerTypeMetaData = this.getTypeMetaData(containerTypeName);
        if (containerTypeMetaData === undefined) {
            throw new Error(`${containerTypeName} is not a valid container $type.`);
        }
        const propertyMetaData = containerTypeMetaData.$properties[refInfo.property]; //  as keyof langium.SpecificPropertiesToString<langium.AstNode>
        if (propertyMetaData === undefined) {
            throw new Error(`'${refInfo.property}' is not a valid property of the container $type ${containerTypeName}.`);
        }
        if (propertyMetaData.kind !== 'Reference') {
            throw new Error(`'${refInfo.property}' is no Reference, but ${propertyMetaData.kind}.`);
        }
        return propertyMetaData.type;
    }

    getTypeMetaData(type: string): langium.TypeMetaData | undefined {
        return this[type as keyof LangiumGrammarAstReflection] as (langium.TypeMetaData | undefined);
    }
}

export const reflection = new LangiumGrammarAstReflection();
